// <auto-generated>
//    Code generated by protoc-gen-cosmos-csharp plugin.  DO NOT EDIT!
//    The plugin is part of the DecentralCardGame project and written by lxgr@protonmail.com
//    source: cardchain/cardchain/tx.proto
// </auto-generated>
#nullable enable

using System;
using Cosmcs.Client;
using Cosmcs.Tx;
using System.Threading.Tasks;
using Google.Protobuf.WellKnownTypes;
using Google.Protobuf;

namespace Cardchain.Cardchain {
	
	public class MsgClient {
		public IClient Client { get; }

		[global::System.CodeDom.Compiler.GeneratedCode("protoc-gen-cosmos-csharp", null)]
		public MsgClient (IClient client) {
			Client = client;
		}
        
        /// <summary>
      	/// SendMsgUpdateParams sends a MsgUpdateParams transaction to the blockchain and waits
      	/// for a response.
      	/// </summary>
      	/// <param name="msg">The MsgUpdateParams message that should be send.</param>
      	/// <param name="fee">The fees that will be paid.</param>
        [global::System.CodeDom.Compiler.GeneratedCode("protoc-gen-cosmos-csharp", null)]
        public Task<Cosmcs.Client.ClientResponse<MsgUpdateParamsResponse>> SendMsgUpdateParams(MsgUpdateParams msg, Cosmcs.Tx.Fee? fee = null) {
			return Client.BuildAndBroadcast(new Any[] {
				new Any
				{
					Value = msg.ToByteString(),
					TypeUrl = "/cardchain.cardchain.MsgUpdateParams"
				}},
				fee
			).ContinueWith(r =>
			{
				var res = r.Result;
				if (res.TxResponse.Code != 0)
				{
					return res.TxResponse;
				}
				System.Threading.Thread.Sleep(13000);
				return Client.QueryTx(res.TxResponse.Txhash).Result.TxResponse;
			})
			.ContinueWith(r => new Cosmcs.Client.ClientResponse<MsgUpdateParamsResponse>(
				r.Result,
				MsgUpdateParamsResponse.Parser
			));
		}

		/// <summary>
      	/// SimulateMsgUpdateParams simulates a MsgUpdateParams transaction on the blockchain.
      	/// </summary>
      	/// <param name="msg">The MsgUpdateParams message that should be simulated.</param>
		[global::System.CodeDom.Compiler.GeneratedCode("protoc-gen-cosmos-csharp", null)]
		public Task<Cosmos.Tx.V1beta1.SimulateResponse> SimulateMsgUpdateParams(MsgUpdateParams msg) {
			return Client.BuildAndSimulate(new Any[] {
				new Any
				{
					Value = msg.ToByteString(),
					TypeUrl = "/cardchain.cardchain.MsgUpdateParams"
				}}
			);
		}

		/// <summary>
      	/// SimulateAndSendMsgUpdateParams simulates, estimates fees and then sends a UpdateParams transaction to the blockchain.
      	/// </summary>
      	/// <param name="msg">The MsgUpdateParams message that should be send.</param>
		[global::System.CodeDom.Compiler.GeneratedCode("protoc-gen-cosmos-csharp", null)]
		public Task<Cosmcs.Client.ClientResponse<MsgUpdateParamsResponse>> SimulateAndSendMsgUpdateParams(MsgUpdateParams msg) {
			return SimulateMsgUpdateParams(msg).ContinueWith(r => {
				return SendMsgUpdateParams(msg, new Cosmcs.Tx.Fee((ulong) Math.Ceiling(r.Result.GasInfo.GasUsed * 1.5))).Result;
			});
		}
        
        /// <summary>
      	/// SendMsgUserCreate sends a MsgUserCreate transaction to the blockchain and waits
      	/// for a response.
      	/// </summary>
      	/// <param name="msg">The MsgUserCreate message that should be send.</param>
      	/// <param name="fee">The fees that will be paid.</param>
        [global::System.CodeDom.Compiler.GeneratedCode("protoc-gen-cosmos-csharp", null)]
        public Task<Cosmcs.Client.ClientResponse<MsgUserCreateResponse>> SendMsgUserCreate(MsgUserCreate msg, Cosmcs.Tx.Fee? fee = null) {
			return Client.BuildAndBroadcast(new Any[] {
				new Any
				{
					Value = msg.ToByteString(),
					TypeUrl = "/cardchain.cardchain.MsgUserCreate"
				}},
				fee
			).ContinueWith(r =>
			{
				var res = r.Result;
				if (res.TxResponse.Code != 0)
				{
					return res.TxResponse;
				}
				System.Threading.Thread.Sleep(13000);
				return Client.QueryTx(res.TxResponse.Txhash).Result.TxResponse;
			})
			.ContinueWith(r => new Cosmcs.Client.ClientResponse<MsgUserCreateResponse>(
				r.Result,
				MsgUserCreateResponse.Parser
			));
		}

		/// <summary>
      	/// SimulateMsgUserCreate simulates a MsgUserCreate transaction on the blockchain.
      	/// </summary>
      	/// <param name="msg">The MsgUserCreate message that should be simulated.</param>
		[global::System.CodeDom.Compiler.GeneratedCode("protoc-gen-cosmos-csharp", null)]
		public Task<Cosmos.Tx.V1beta1.SimulateResponse> SimulateMsgUserCreate(MsgUserCreate msg) {
			return Client.BuildAndSimulate(new Any[] {
				new Any
				{
					Value = msg.ToByteString(),
					TypeUrl = "/cardchain.cardchain.MsgUserCreate"
				}}
			);
		}

		/// <summary>
      	/// SimulateAndSendMsgUserCreate simulates, estimates fees and then sends a UserCreate transaction to the blockchain.
      	/// </summary>
      	/// <param name="msg">The MsgUserCreate message that should be send.</param>
		[global::System.CodeDom.Compiler.GeneratedCode("protoc-gen-cosmos-csharp", null)]
		public Task<Cosmcs.Client.ClientResponse<MsgUserCreateResponse>> SimulateAndSendMsgUserCreate(MsgUserCreate msg) {
			return SimulateMsgUserCreate(msg).ContinueWith(r => {
				return SendMsgUserCreate(msg, new Cosmcs.Tx.Fee((ulong) Math.Ceiling(r.Result.GasInfo.GasUsed * 1.5))).Result;
			});
		}
        
        /// <summary>
      	/// SendMsgCardSchemeBuy sends a MsgCardSchemeBuy transaction to the blockchain and waits
      	/// for a response.
      	/// </summary>
      	/// <param name="msg">The MsgCardSchemeBuy message that should be send.</param>
      	/// <param name="fee">The fees that will be paid.</param>
        [global::System.CodeDom.Compiler.GeneratedCode("protoc-gen-cosmos-csharp", null)]
        public Task<Cosmcs.Client.ClientResponse<MsgCardSchemeBuyResponse>> SendMsgCardSchemeBuy(MsgCardSchemeBuy msg, Cosmcs.Tx.Fee? fee = null) {
			return Client.BuildAndBroadcast(new Any[] {
				new Any
				{
					Value = msg.ToByteString(),
					TypeUrl = "/cardchain.cardchain.MsgCardSchemeBuy"
				}},
				fee
			).ContinueWith(r =>
			{
				var res = r.Result;
				if (res.TxResponse.Code != 0)
				{
					return res.TxResponse;
				}
				System.Threading.Thread.Sleep(13000);
				return Client.QueryTx(res.TxResponse.Txhash).Result.TxResponse;
			})
			.ContinueWith(r => new Cosmcs.Client.ClientResponse<MsgCardSchemeBuyResponse>(
				r.Result,
				MsgCardSchemeBuyResponse.Parser
			));
		}

		/// <summary>
      	/// SimulateMsgCardSchemeBuy simulates a MsgCardSchemeBuy transaction on the blockchain.
      	/// </summary>
      	/// <param name="msg">The MsgCardSchemeBuy message that should be simulated.</param>
		[global::System.CodeDom.Compiler.GeneratedCode("protoc-gen-cosmos-csharp", null)]
		public Task<Cosmos.Tx.V1beta1.SimulateResponse> SimulateMsgCardSchemeBuy(MsgCardSchemeBuy msg) {
			return Client.BuildAndSimulate(new Any[] {
				new Any
				{
					Value = msg.ToByteString(),
					TypeUrl = "/cardchain.cardchain.MsgCardSchemeBuy"
				}}
			);
		}

		/// <summary>
      	/// SimulateAndSendMsgCardSchemeBuy simulates, estimates fees and then sends a CardSchemeBuy transaction to the blockchain.
      	/// </summary>
      	/// <param name="msg">The MsgCardSchemeBuy message that should be send.</param>
		[global::System.CodeDom.Compiler.GeneratedCode("protoc-gen-cosmos-csharp", null)]
		public Task<Cosmcs.Client.ClientResponse<MsgCardSchemeBuyResponse>> SimulateAndSendMsgCardSchemeBuy(MsgCardSchemeBuy msg) {
			return SimulateMsgCardSchemeBuy(msg).ContinueWith(r => {
				return SendMsgCardSchemeBuy(msg, new Cosmcs.Tx.Fee((ulong) Math.Ceiling(r.Result.GasInfo.GasUsed * 1.5))).Result;
			});
		}
        
        /// <summary>
      	/// SendMsgCardSaveContent sends a MsgCardSaveContent transaction to the blockchain and waits
      	/// for a response.
      	/// </summary>
      	/// <param name="msg">The MsgCardSaveContent message that should be send.</param>
      	/// <param name="fee">The fees that will be paid.</param>
        [global::System.CodeDom.Compiler.GeneratedCode("protoc-gen-cosmos-csharp", null)]
        public Task<Cosmcs.Client.ClientResponse<MsgCardSaveContentResponse>> SendMsgCardSaveContent(MsgCardSaveContent msg, Cosmcs.Tx.Fee? fee = null) {
			return Client.BuildAndBroadcast(new Any[] {
				new Any
				{
					Value = msg.ToByteString(),
					TypeUrl = "/cardchain.cardchain.MsgCardSaveContent"
				}},
				fee
			).ContinueWith(r =>
			{
				var res = r.Result;
				if (res.TxResponse.Code != 0)
				{
					return res.TxResponse;
				}
				System.Threading.Thread.Sleep(13000);
				return Client.QueryTx(res.TxResponse.Txhash).Result.TxResponse;
			})
			.ContinueWith(r => new Cosmcs.Client.ClientResponse<MsgCardSaveContentResponse>(
				r.Result,
				MsgCardSaveContentResponse.Parser
			));
		}

		/// <summary>
      	/// SimulateMsgCardSaveContent simulates a MsgCardSaveContent transaction on the blockchain.
      	/// </summary>
      	/// <param name="msg">The MsgCardSaveContent message that should be simulated.</param>
		[global::System.CodeDom.Compiler.GeneratedCode("protoc-gen-cosmos-csharp", null)]
		public Task<Cosmos.Tx.V1beta1.SimulateResponse> SimulateMsgCardSaveContent(MsgCardSaveContent msg) {
			return Client.BuildAndSimulate(new Any[] {
				new Any
				{
					Value = msg.ToByteString(),
					TypeUrl = "/cardchain.cardchain.MsgCardSaveContent"
				}}
			);
		}

		/// <summary>
      	/// SimulateAndSendMsgCardSaveContent simulates, estimates fees and then sends a CardSaveContent transaction to the blockchain.
      	/// </summary>
      	/// <param name="msg">The MsgCardSaveContent message that should be send.</param>
		[global::System.CodeDom.Compiler.GeneratedCode("protoc-gen-cosmos-csharp", null)]
		public Task<Cosmcs.Client.ClientResponse<MsgCardSaveContentResponse>> SimulateAndSendMsgCardSaveContent(MsgCardSaveContent msg) {
			return SimulateMsgCardSaveContent(msg).ContinueWith(r => {
				return SendMsgCardSaveContent(msg, new Cosmcs.Tx.Fee((ulong) Math.Ceiling(r.Result.GasInfo.GasUsed * 1.5))).Result;
			});
		}
        
        /// <summary>
      	/// SendMsgCardVote sends a MsgCardVote transaction to the blockchain and waits
      	/// for a response.
      	/// </summary>
      	/// <param name="msg">The MsgCardVote message that should be send.</param>
      	/// <param name="fee">The fees that will be paid.</param>
        [global::System.CodeDom.Compiler.GeneratedCode("protoc-gen-cosmos-csharp", null)]
        public Task<Cosmcs.Client.ClientResponse<MsgCardVoteResponse>> SendMsgCardVote(MsgCardVote msg, Cosmcs.Tx.Fee? fee = null) {
			return Client.BuildAndBroadcast(new Any[] {
				new Any
				{
					Value = msg.ToByteString(),
					TypeUrl = "/cardchain.cardchain.MsgCardVote"
				}},
				fee
			).ContinueWith(r =>
			{
				var res = r.Result;
				if (res.TxResponse.Code != 0)
				{
					return res.TxResponse;
				}
				System.Threading.Thread.Sleep(13000);
				return Client.QueryTx(res.TxResponse.Txhash).Result.TxResponse;
			})
			.ContinueWith(r => new Cosmcs.Client.ClientResponse<MsgCardVoteResponse>(
				r.Result,
				MsgCardVoteResponse.Parser
			));
		}

		/// <summary>
      	/// SimulateMsgCardVote simulates a MsgCardVote transaction on the blockchain.
      	/// </summary>
      	/// <param name="msg">The MsgCardVote message that should be simulated.</param>
		[global::System.CodeDom.Compiler.GeneratedCode("protoc-gen-cosmos-csharp", null)]
		public Task<Cosmos.Tx.V1beta1.SimulateResponse> SimulateMsgCardVote(MsgCardVote msg) {
			return Client.BuildAndSimulate(new Any[] {
				new Any
				{
					Value = msg.ToByteString(),
					TypeUrl = "/cardchain.cardchain.MsgCardVote"
				}}
			);
		}

		/// <summary>
      	/// SimulateAndSendMsgCardVote simulates, estimates fees and then sends a CardVote transaction to the blockchain.
      	/// </summary>
      	/// <param name="msg">The MsgCardVote message that should be send.</param>
		[global::System.CodeDom.Compiler.GeneratedCode("protoc-gen-cosmos-csharp", null)]
		public Task<Cosmcs.Client.ClientResponse<MsgCardVoteResponse>> SimulateAndSendMsgCardVote(MsgCardVote msg) {
			return SimulateMsgCardVote(msg).ContinueWith(r => {
				return SendMsgCardVote(msg, new Cosmcs.Tx.Fee((ulong) Math.Ceiling(r.Result.GasInfo.GasUsed * 1.5))).Result;
			});
		}
        
        /// <summary>
      	/// SendMsgCardTransfer sends a MsgCardTransfer transaction to the blockchain and waits
      	/// for a response.
      	/// </summary>
      	/// <param name="msg">The MsgCardTransfer message that should be send.</param>
      	/// <param name="fee">The fees that will be paid.</param>
        [global::System.CodeDom.Compiler.GeneratedCode("protoc-gen-cosmos-csharp", null)]
        public Task<Cosmcs.Client.ClientResponse<MsgCardTransferResponse>> SendMsgCardTransfer(MsgCardTransfer msg, Cosmcs.Tx.Fee? fee = null) {
			return Client.BuildAndBroadcast(new Any[] {
				new Any
				{
					Value = msg.ToByteString(),
					TypeUrl = "/cardchain.cardchain.MsgCardTransfer"
				}},
				fee
			).ContinueWith(r =>
			{
				var res = r.Result;
				if (res.TxResponse.Code != 0)
				{
					return res.TxResponse;
				}
				System.Threading.Thread.Sleep(13000);
				return Client.QueryTx(res.TxResponse.Txhash).Result.TxResponse;
			})
			.ContinueWith(r => new Cosmcs.Client.ClientResponse<MsgCardTransferResponse>(
				r.Result,
				MsgCardTransferResponse.Parser
			));
		}

		/// <summary>
      	/// SimulateMsgCardTransfer simulates a MsgCardTransfer transaction on the blockchain.
      	/// </summary>
      	/// <param name="msg">The MsgCardTransfer message that should be simulated.</param>
		[global::System.CodeDom.Compiler.GeneratedCode("protoc-gen-cosmos-csharp", null)]
		public Task<Cosmos.Tx.V1beta1.SimulateResponse> SimulateMsgCardTransfer(MsgCardTransfer msg) {
			return Client.BuildAndSimulate(new Any[] {
				new Any
				{
					Value = msg.ToByteString(),
					TypeUrl = "/cardchain.cardchain.MsgCardTransfer"
				}}
			);
		}

		/// <summary>
      	/// SimulateAndSendMsgCardTransfer simulates, estimates fees and then sends a CardTransfer transaction to the blockchain.
      	/// </summary>
      	/// <param name="msg">The MsgCardTransfer message that should be send.</param>
		[global::System.CodeDom.Compiler.GeneratedCode("protoc-gen-cosmos-csharp", null)]
		public Task<Cosmcs.Client.ClientResponse<MsgCardTransferResponse>> SimulateAndSendMsgCardTransfer(MsgCardTransfer msg) {
			return SimulateMsgCardTransfer(msg).ContinueWith(r => {
				return SendMsgCardTransfer(msg, new Cosmcs.Tx.Fee((ulong) Math.Ceiling(r.Result.GasInfo.GasUsed * 1.5))).Result;
			});
		}
        
        /// <summary>
      	/// SendMsgCardDonate sends a MsgCardDonate transaction to the blockchain and waits
      	/// for a response.
      	/// </summary>
      	/// <param name="msg">The MsgCardDonate message that should be send.</param>
      	/// <param name="fee">The fees that will be paid.</param>
        [global::System.CodeDom.Compiler.GeneratedCode("protoc-gen-cosmos-csharp", null)]
        public Task<Cosmcs.Client.ClientResponse<MsgCardDonateResponse>> SendMsgCardDonate(MsgCardDonate msg, Cosmcs.Tx.Fee? fee = null) {
			return Client.BuildAndBroadcast(new Any[] {
				new Any
				{
					Value = msg.ToByteString(),
					TypeUrl = "/cardchain.cardchain.MsgCardDonate"
				}},
				fee
			).ContinueWith(r =>
			{
				var res = r.Result;
				if (res.TxResponse.Code != 0)
				{
					return res.TxResponse;
				}
				System.Threading.Thread.Sleep(13000);
				return Client.QueryTx(res.TxResponse.Txhash).Result.TxResponse;
			})
			.ContinueWith(r => new Cosmcs.Client.ClientResponse<MsgCardDonateResponse>(
				r.Result,
				MsgCardDonateResponse.Parser
			));
		}

		/// <summary>
      	/// SimulateMsgCardDonate simulates a MsgCardDonate transaction on the blockchain.
      	/// </summary>
      	/// <param name="msg">The MsgCardDonate message that should be simulated.</param>
		[global::System.CodeDom.Compiler.GeneratedCode("protoc-gen-cosmos-csharp", null)]
		public Task<Cosmos.Tx.V1beta1.SimulateResponse> SimulateMsgCardDonate(MsgCardDonate msg) {
			return Client.BuildAndSimulate(new Any[] {
				new Any
				{
					Value = msg.ToByteString(),
					TypeUrl = "/cardchain.cardchain.MsgCardDonate"
				}}
			);
		}

		/// <summary>
      	/// SimulateAndSendMsgCardDonate simulates, estimates fees and then sends a CardDonate transaction to the blockchain.
      	/// </summary>
      	/// <param name="msg">The MsgCardDonate message that should be send.</param>
		[global::System.CodeDom.Compiler.GeneratedCode("protoc-gen-cosmos-csharp", null)]
		public Task<Cosmcs.Client.ClientResponse<MsgCardDonateResponse>> SimulateAndSendMsgCardDonate(MsgCardDonate msg) {
			return SimulateMsgCardDonate(msg).ContinueWith(r => {
				return SendMsgCardDonate(msg, new Cosmcs.Tx.Fee((ulong) Math.Ceiling(r.Result.GasInfo.GasUsed * 1.5))).Result;
			});
		}
        
        /// <summary>
      	/// SendMsgCardArtworkAdd sends a MsgCardArtworkAdd transaction to the blockchain and waits
      	/// for a response.
      	/// </summary>
      	/// <param name="msg">The MsgCardArtworkAdd message that should be send.</param>
      	/// <param name="fee">The fees that will be paid.</param>
        [global::System.CodeDom.Compiler.GeneratedCode("protoc-gen-cosmos-csharp", null)]
        public Task<Cosmcs.Client.ClientResponse<MsgCardArtworkAddResponse>> SendMsgCardArtworkAdd(MsgCardArtworkAdd msg, Cosmcs.Tx.Fee? fee = null) {
			return Client.BuildAndBroadcast(new Any[] {
				new Any
				{
					Value = msg.ToByteString(),
					TypeUrl = "/cardchain.cardchain.MsgCardArtworkAdd"
				}},
				fee
			).ContinueWith(r =>
			{
				var res = r.Result;
				if (res.TxResponse.Code != 0)
				{
					return res.TxResponse;
				}
				System.Threading.Thread.Sleep(13000);
				return Client.QueryTx(res.TxResponse.Txhash).Result.TxResponse;
			})
			.ContinueWith(r => new Cosmcs.Client.ClientResponse<MsgCardArtworkAddResponse>(
				r.Result,
				MsgCardArtworkAddResponse.Parser
			));
		}

		/// <summary>
      	/// SimulateMsgCardArtworkAdd simulates a MsgCardArtworkAdd transaction on the blockchain.
      	/// </summary>
      	/// <param name="msg">The MsgCardArtworkAdd message that should be simulated.</param>
		[global::System.CodeDom.Compiler.GeneratedCode("protoc-gen-cosmos-csharp", null)]
		public Task<Cosmos.Tx.V1beta1.SimulateResponse> SimulateMsgCardArtworkAdd(MsgCardArtworkAdd msg) {
			return Client.BuildAndSimulate(new Any[] {
				new Any
				{
					Value = msg.ToByteString(),
					TypeUrl = "/cardchain.cardchain.MsgCardArtworkAdd"
				}}
			);
		}

		/// <summary>
      	/// SimulateAndSendMsgCardArtworkAdd simulates, estimates fees and then sends a CardArtworkAdd transaction to the blockchain.
      	/// </summary>
      	/// <param name="msg">The MsgCardArtworkAdd message that should be send.</param>
		[global::System.CodeDom.Compiler.GeneratedCode("protoc-gen-cosmos-csharp", null)]
		public Task<Cosmcs.Client.ClientResponse<MsgCardArtworkAddResponse>> SimulateAndSendMsgCardArtworkAdd(MsgCardArtworkAdd msg) {
			return SimulateMsgCardArtworkAdd(msg).ContinueWith(r => {
				return SendMsgCardArtworkAdd(msg, new Cosmcs.Tx.Fee((ulong) Math.Ceiling(r.Result.GasInfo.GasUsed * 1.5))).Result;
			});
		}
        
        /// <summary>
      	/// SendMsgCardArtistChange sends a MsgCardArtistChange transaction to the blockchain and waits
      	/// for a response.
      	/// </summary>
      	/// <param name="msg">The MsgCardArtistChange message that should be send.</param>
      	/// <param name="fee">The fees that will be paid.</param>
        [global::System.CodeDom.Compiler.GeneratedCode("protoc-gen-cosmos-csharp", null)]
        public Task<Cosmcs.Client.ClientResponse<MsgCardArtistChangeResponse>> SendMsgCardArtistChange(MsgCardArtistChange msg, Cosmcs.Tx.Fee? fee = null) {
			return Client.BuildAndBroadcast(new Any[] {
				new Any
				{
					Value = msg.ToByteString(),
					TypeUrl = "/cardchain.cardchain.MsgCardArtistChange"
				}},
				fee
			).ContinueWith(r =>
			{
				var res = r.Result;
				if (res.TxResponse.Code != 0)
				{
					return res.TxResponse;
				}
				System.Threading.Thread.Sleep(13000);
				return Client.QueryTx(res.TxResponse.Txhash).Result.TxResponse;
			})
			.ContinueWith(r => new Cosmcs.Client.ClientResponse<MsgCardArtistChangeResponse>(
				r.Result,
				MsgCardArtistChangeResponse.Parser
			));
		}

		/// <summary>
      	/// SimulateMsgCardArtistChange simulates a MsgCardArtistChange transaction on the blockchain.
      	/// </summary>
      	/// <param name="msg">The MsgCardArtistChange message that should be simulated.</param>
		[global::System.CodeDom.Compiler.GeneratedCode("protoc-gen-cosmos-csharp", null)]
		public Task<Cosmos.Tx.V1beta1.SimulateResponse> SimulateMsgCardArtistChange(MsgCardArtistChange msg) {
			return Client.BuildAndSimulate(new Any[] {
				new Any
				{
					Value = msg.ToByteString(),
					TypeUrl = "/cardchain.cardchain.MsgCardArtistChange"
				}}
			);
		}

		/// <summary>
      	/// SimulateAndSendMsgCardArtistChange simulates, estimates fees and then sends a CardArtistChange transaction to the blockchain.
      	/// </summary>
      	/// <param name="msg">The MsgCardArtistChange message that should be send.</param>
		[global::System.CodeDom.Compiler.GeneratedCode("protoc-gen-cosmos-csharp", null)]
		public Task<Cosmcs.Client.ClientResponse<MsgCardArtistChangeResponse>> SimulateAndSendMsgCardArtistChange(MsgCardArtistChange msg) {
			return SimulateMsgCardArtistChange(msg).ContinueWith(r => {
				return SendMsgCardArtistChange(msg, new Cosmcs.Tx.Fee((ulong) Math.Ceiling(r.Result.GasInfo.GasUsed * 1.5))).Result;
			});
		}
        
        /// <summary>
      	/// SendMsgCouncilRegister sends a MsgCouncilRegister transaction to the blockchain and waits
      	/// for a response.
      	/// </summary>
      	/// <param name="msg">The MsgCouncilRegister message that should be send.</param>
      	/// <param name="fee">The fees that will be paid.</param>
        [global::System.CodeDom.Compiler.GeneratedCode("protoc-gen-cosmos-csharp", null)]
        public Task<Cosmcs.Client.ClientResponse<MsgCouncilRegisterResponse>> SendMsgCouncilRegister(MsgCouncilRegister msg, Cosmcs.Tx.Fee? fee = null) {
			return Client.BuildAndBroadcast(new Any[] {
				new Any
				{
					Value = msg.ToByteString(),
					TypeUrl = "/cardchain.cardchain.MsgCouncilRegister"
				}},
				fee
			).ContinueWith(r =>
			{
				var res = r.Result;
				if (res.TxResponse.Code != 0)
				{
					return res.TxResponse;
				}
				System.Threading.Thread.Sleep(13000);
				return Client.QueryTx(res.TxResponse.Txhash).Result.TxResponse;
			})
			.ContinueWith(r => new Cosmcs.Client.ClientResponse<MsgCouncilRegisterResponse>(
				r.Result,
				MsgCouncilRegisterResponse.Parser
			));
		}

		/// <summary>
      	/// SimulateMsgCouncilRegister simulates a MsgCouncilRegister transaction on the blockchain.
      	/// </summary>
      	/// <param name="msg">The MsgCouncilRegister message that should be simulated.</param>
		[global::System.CodeDom.Compiler.GeneratedCode("protoc-gen-cosmos-csharp", null)]
		public Task<Cosmos.Tx.V1beta1.SimulateResponse> SimulateMsgCouncilRegister(MsgCouncilRegister msg) {
			return Client.BuildAndSimulate(new Any[] {
				new Any
				{
					Value = msg.ToByteString(),
					TypeUrl = "/cardchain.cardchain.MsgCouncilRegister"
				}}
			);
		}

		/// <summary>
      	/// SimulateAndSendMsgCouncilRegister simulates, estimates fees and then sends a CouncilRegister transaction to the blockchain.
      	/// </summary>
      	/// <param name="msg">The MsgCouncilRegister message that should be send.</param>
		[global::System.CodeDom.Compiler.GeneratedCode("protoc-gen-cosmos-csharp", null)]
		public Task<Cosmcs.Client.ClientResponse<MsgCouncilRegisterResponse>> SimulateAndSendMsgCouncilRegister(MsgCouncilRegister msg) {
			return SimulateMsgCouncilRegister(msg).ContinueWith(r => {
				return SendMsgCouncilRegister(msg, new Cosmcs.Tx.Fee((ulong) Math.Ceiling(r.Result.GasInfo.GasUsed * 1.5))).Result;
			});
		}
        
        /// <summary>
      	/// SendMsgCouncilDeregister sends a MsgCouncilDeregister transaction to the blockchain and waits
      	/// for a response.
      	/// </summary>
      	/// <param name="msg">The MsgCouncilDeregister message that should be send.</param>
      	/// <param name="fee">The fees that will be paid.</param>
        [global::System.CodeDom.Compiler.GeneratedCode("protoc-gen-cosmos-csharp", null)]
        public Task<Cosmcs.Client.ClientResponse<MsgCouncilDeregisterResponse>> SendMsgCouncilDeregister(MsgCouncilDeregister msg, Cosmcs.Tx.Fee? fee = null) {
			return Client.BuildAndBroadcast(new Any[] {
				new Any
				{
					Value = msg.ToByteString(),
					TypeUrl = "/cardchain.cardchain.MsgCouncilDeregister"
				}},
				fee
			).ContinueWith(r =>
			{
				var res = r.Result;
				if (res.TxResponse.Code != 0)
				{
					return res.TxResponse;
				}
				System.Threading.Thread.Sleep(13000);
				return Client.QueryTx(res.TxResponse.Txhash).Result.TxResponse;
			})
			.ContinueWith(r => new Cosmcs.Client.ClientResponse<MsgCouncilDeregisterResponse>(
				r.Result,
				MsgCouncilDeregisterResponse.Parser
			));
		}

		/// <summary>
      	/// SimulateMsgCouncilDeregister simulates a MsgCouncilDeregister transaction on the blockchain.
      	/// </summary>
      	/// <param name="msg">The MsgCouncilDeregister message that should be simulated.</param>
		[global::System.CodeDom.Compiler.GeneratedCode("protoc-gen-cosmos-csharp", null)]
		public Task<Cosmos.Tx.V1beta1.SimulateResponse> SimulateMsgCouncilDeregister(MsgCouncilDeregister msg) {
			return Client.BuildAndSimulate(new Any[] {
				new Any
				{
					Value = msg.ToByteString(),
					TypeUrl = "/cardchain.cardchain.MsgCouncilDeregister"
				}}
			);
		}

		/// <summary>
      	/// SimulateAndSendMsgCouncilDeregister simulates, estimates fees and then sends a CouncilDeregister transaction to the blockchain.
      	/// </summary>
      	/// <param name="msg">The MsgCouncilDeregister message that should be send.</param>
		[global::System.CodeDom.Compiler.GeneratedCode("protoc-gen-cosmos-csharp", null)]
		public Task<Cosmcs.Client.ClientResponse<MsgCouncilDeregisterResponse>> SimulateAndSendMsgCouncilDeregister(MsgCouncilDeregister msg) {
			return SimulateMsgCouncilDeregister(msg).ContinueWith(r => {
				return SendMsgCouncilDeregister(msg, new Cosmcs.Tx.Fee((ulong) Math.Ceiling(r.Result.GasInfo.GasUsed * 1.5))).Result;
			});
		}
        
        /// <summary>
      	/// SendMsgMatchReport sends a MsgMatchReport transaction to the blockchain and waits
      	/// for a response.
      	/// </summary>
      	/// <param name="msg">The MsgMatchReport message that should be send.</param>
      	/// <param name="fee">The fees that will be paid.</param>
        [global::System.CodeDom.Compiler.GeneratedCode("protoc-gen-cosmos-csharp", null)]
        public Task<Cosmcs.Client.ClientResponse<MsgMatchReportResponse>> SendMsgMatchReport(MsgMatchReport msg, Cosmcs.Tx.Fee? fee = null) {
			return Client.BuildAndBroadcast(new Any[] {
				new Any
				{
					Value = msg.ToByteString(),
					TypeUrl = "/cardchain.cardchain.MsgMatchReport"
				}},
				fee
			).ContinueWith(r =>
			{
				var res = r.Result;
				if (res.TxResponse.Code != 0)
				{
					return res.TxResponse;
				}
				System.Threading.Thread.Sleep(13000);
				return Client.QueryTx(res.TxResponse.Txhash).Result.TxResponse;
			})
			.ContinueWith(r => new Cosmcs.Client.ClientResponse<MsgMatchReportResponse>(
				r.Result,
				MsgMatchReportResponse.Parser
			));
		}

		/// <summary>
      	/// SimulateMsgMatchReport simulates a MsgMatchReport transaction on the blockchain.
      	/// </summary>
      	/// <param name="msg">The MsgMatchReport message that should be simulated.</param>
		[global::System.CodeDom.Compiler.GeneratedCode("protoc-gen-cosmos-csharp", null)]
		public Task<Cosmos.Tx.V1beta1.SimulateResponse> SimulateMsgMatchReport(MsgMatchReport msg) {
			return Client.BuildAndSimulate(new Any[] {
				new Any
				{
					Value = msg.ToByteString(),
					TypeUrl = "/cardchain.cardchain.MsgMatchReport"
				}}
			);
		}

		/// <summary>
      	/// SimulateAndSendMsgMatchReport simulates, estimates fees and then sends a MatchReport transaction to the blockchain.
      	/// </summary>
      	/// <param name="msg">The MsgMatchReport message that should be send.</param>
		[global::System.CodeDom.Compiler.GeneratedCode("protoc-gen-cosmos-csharp", null)]
		public Task<Cosmcs.Client.ClientResponse<MsgMatchReportResponse>> SimulateAndSendMsgMatchReport(MsgMatchReport msg) {
			return SimulateMsgMatchReport(msg).ContinueWith(r => {
				return SendMsgMatchReport(msg, new Cosmcs.Tx.Fee((ulong) Math.Ceiling(r.Result.GasInfo.GasUsed * 1.5))).Result;
			});
		}
        
        /// <summary>
      	/// SendMsgCouncilCreate sends a MsgCouncilCreate transaction to the blockchain and waits
      	/// for a response.
      	/// </summary>
      	/// <param name="msg">The MsgCouncilCreate message that should be send.</param>
      	/// <param name="fee">The fees that will be paid.</param>
        [global::System.CodeDom.Compiler.GeneratedCode("protoc-gen-cosmos-csharp", null)]
        public Task<Cosmcs.Client.ClientResponse<MsgCouncilCreateResponse>> SendMsgCouncilCreate(MsgCouncilCreate msg, Cosmcs.Tx.Fee? fee = null) {
			return Client.BuildAndBroadcast(new Any[] {
				new Any
				{
					Value = msg.ToByteString(),
					TypeUrl = "/cardchain.cardchain.MsgCouncilCreate"
				}},
				fee
			).ContinueWith(r =>
			{
				var res = r.Result;
				if (res.TxResponse.Code != 0)
				{
					return res.TxResponse;
				}
				System.Threading.Thread.Sleep(13000);
				return Client.QueryTx(res.TxResponse.Txhash).Result.TxResponse;
			})
			.ContinueWith(r => new Cosmcs.Client.ClientResponse<MsgCouncilCreateResponse>(
				r.Result,
				MsgCouncilCreateResponse.Parser
			));
		}

		/// <summary>
      	/// SimulateMsgCouncilCreate simulates a MsgCouncilCreate transaction on the blockchain.
      	/// </summary>
      	/// <param name="msg">The MsgCouncilCreate message that should be simulated.</param>
		[global::System.CodeDom.Compiler.GeneratedCode("protoc-gen-cosmos-csharp", null)]
		public Task<Cosmos.Tx.V1beta1.SimulateResponse> SimulateMsgCouncilCreate(MsgCouncilCreate msg) {
			return Client.BuildAndSimulate(new Any[] {
				new Any
				{
					Value = msg.ToByteString(),
					TypeUrl = "/cardchain.cardchain.MsgCouncilCreate"
				}}
			);
		}

		/// <summary>
      	/// SimulateAndSendMsgCouncilCreate simulates, estimates fees and then sends a CouncilCreate transaction to the blockchain.
      	/// </summary>
      	/// <param name="msg">The MsgCouncilCreate message that should be send.</param>
		[global::System.CodeDom.Compiler.GeneratedCode("protoc-gen-cosmos-csharp", null)]
		public Task<Cosmcs.Client.ClientResponse<MsgCouncilCreateResponse>> SimulateAndSendMsgCouncilCreate(MsgCouncilCreate msg) {
			return SimulateMsgCouncilCreate(msg).ContinueWith(r => {
				return SendMsgCouncilCreate(msg, new Cosmcs.Tx.Fee((ulong) Math.Ceiling(r.Result.GasInfo.GasUsed * 1.5))).Result;
			});
		}
        
        /// <summary>
      	/// SendMsgMatchReporterAppoint sends a MsgMatchReporterAppoint transaction to the blockchain and waits
      	/// for a response.
      	/// </summary>
      	/// <param name="msg">The MsgMatchReporterAppoint message that should be send.</param>
      	/// <param name="fee">The fees that will be paid.</param>
        [global::System.CodeDom.Compiler.GeneratedCode("protoc-gen-cosmos-csharp", null)]
        public Task<Cosmcs.Client.ClientResponse<MsgMatchReporterAppointResponse>> SendMsgMatchReporterAppoint(MsgMatchReporterAppoint msg, Cosmcs.Tx.Fee? fee = null) {
			return Client.BuildAndBroadcast(new Any[] {
				new Any
				{
					Value = msg.ToByteString(),
					TypeUrl = "/cardchain.cardchain.MsgMatchReporterAppoint"
				}},
				fee
			).ContinueWith(r =>
			{
				var res = r.Result;
				if (res.TxResponse.Code != 0)
				{
					return res.TxResponse;
				}
				System.Threading.Thread.Sleep(13000);
				return Client.QueryTx(res.TxResponse.Txhash).Result.TxResponse;
			})
			.ContinueWith(r => new Cosmcs.Client.ClientResponse<MsgMatchReporterAppointResponse>(
				r.Result,
				MsgMatchReporterAppointResponse.Parser
			));
		}

		/// <summary>
      	/// SimulateMsgMatchReporterAppoint simulates a MsgMatchReporterAppoint transaction on the blockchain.
      	/// </summary>
      	/// <param name="msg">The MsgMatchReporterAppoint message that should be simulated.</param>
		[global::System.CodeDom.Compiler.GeneratedCode("protoc-gen-cosmos-csharp", null)]
		public Task<Cosmos.Tx.V1beta1.SimulateResponse> SimulateMsgMatchReporterAppoint(MsgMatchReporterAppoint msg) {
			return Client.BuildAndSimulate(new Any[] {
				new Any
				{
					Value = msg.ToByteString(),
					TypeUrl = "/cardchain.cardchain.MsgMatchReporterAppoint"
				}}
			);
		}

		/// <summary>
      	/// SimulateAndSendMsgMatchReporterAppoint simulates, estimates fees and then sends a MatchReporterAppoint transaction to the blockchain.
      	/// </summary>
      	/// <param name="msg">The MsgMatchReporterAppoint message that should be send.</param>
		[global::System.CodeDom.Compiler.GeneratedCode("protoc-gen-cosmos-csharp", null)]
		public Task<Cosmcs.Client.ClientResponse<MsgMatchReporterAppointResponse>> SimulateAndSendMsgMatchReporterAppoint(MsgMatchReporterAppoint msg) {
			return SimulateMsgMatchReporterAppoint(msg).ContinueWith(r => {
				return SendMsgMatchReporterAppoint(msg, new Cosmcs.Tx.Fee((ulong) Math.Ceiling(r.Result.GasInfo.GasUsed * 1.5))).Result;
			});
		}
        
        /// <summary>
      	/// SendMsgSetCreate sends a MsgSetCreate transaction to the blockchain and waits
      	/// for a response.
      	/// </summary>
      	/// <param name="msg">The MsgSetCreate message that should be send.</param>
      	/// <param name="fee">The fees that will be paid.</param>
        [global::System.CodeDom.Compiler.GeneratedCode("protoc-gen-cosmos-csharp", null)]
        public Task<Cosmcs.Client.ClientResponse<MsgSetCreateResponse>> SendMsgSetCreate(MsgSetCreate msg, Cosmcs.Tx.Fee? fee = null) {
			return Client.BuildAndBroadcast(new Any[] {
				new Any
				{
					Value = msg.ToByteString(),
					TypeUrl = "/cardchain.cardchain.MsgSetCreate"
				}},
				fee
			).ContinueWith(r =>
			{
				var res = r.Result;
				if (res.TxResponse.Code != 0)
				{
					return res.TxResponse;
				}
				System.Threading.Thread.Sleep(13000);
				return Client.QueryTx(res.TxResponse.Txhash).Result.TxResponse;
			})
			.ContinueWith(r => new Cosmcs.Client.ClientResponse<MsgSetCreateResponse>(
				r.Result,
				MsgSetCreateResponse.Parser
			));
		}

		/// <summary>
      	/// SimulateMsgSetCreate simulates a MsgSetCreate transaction on the blockchain.
      	/// </summary>
      	/// <param name="msg">The MsgSetCreate message that should be simulated.</param>
		[global::System.CodeDom.Compiler.GeneratedCode("protoc-gen-cosmos-csharp", null)]
		public Task<Cosmos.Tx.V1beta1.SimulateResponse> SimulateMsgSetCreate(MsgSetCreate msg) {
			return Client.BuildAndSimulate(new Any[] {
				new Any
				{
					Value = msg.ToByteString(),
					TypeUrl = "/cardchain.cardchain.MsgSetCreate"
				}}
			);
		}

		/// <summary>
      	/// SimulateAndSendMsgSetCreate simulates, estimates fees and then sends a SetCreate transaction to the blockchain.
      	/// </summary>
      	/// <param name="msg">The MsgSetCreate message that should be send.</param>
		[global::System.CodeDom.Compiler.GeneratedCode("protoc-gen-cosmos-csharp", null)]
		public Task<Cosmcs.Client.ClientResponse<MsgSetCreateResponse>> SimulateAndSendMsgSetCreate(MsgSetCreate msg) {
			return SimulateMsgSetCreate(msg).ContinueWith(r => {
				return SendMsgSetCreate(msg, new Cosmcs.Tx.Fee((ulong) Math.Ceiling(r.Result.GasInfo.GasUsed * 1.5))).Result;
			});
		}
        
        /// <summary>
      	/// SendMsgSetCardAdd sends a MsgSetCardAdd transaction to the blockchain and waits
      	/// for a response.
      	/// </summary>
      	/// <param name="msg">The MsgSetCardAdd message that should be send.</param>
      	/// <param name="fee">The fees that will be paid.</param>
        [global::System.CodeDom.Compiler.GeneratedCode("protoc-gen-cosmos-csharp", null)]
        public Task<Cosmcs.Client.ClientResponse<MsgSetCardAddResponse>> SendMsgSetCardAdd(MsgSetCardAdd msg, Cosmcs.Tx.Fee? fee = null) {
			return Client.BuildAndBroadcast(new Any[] {
				new Any
				{
					Value = msg.ToByteString(),
					TypeUrl = "/cardchain.cardchain.MsgSetCardAdd"
				}},
				fee
			).ContinueWith(r =>
			{
				var res = r.Result;
				if (res.TxResponse.Code != 0)
				{
					return res.TxResponse;
				}
				System.Threading.Thread.Sleep(13000);
				return Client.QueryTx(res.TxResponse.Txhash).Result.TxResponse;
			})
			.ContinueWith(r => new Cosmcs.Client.ClientResponse<MsgSetCardAddResponse>(
				r.Result,
				MsgSetCardAddResponse.Parser
			));
		}

		/// <summary>
      	/// SimulateMsgSetCardAdd simulates a MsgSetCardAdd transaction on the blockchain.
      	/// </summary>
      	/// <param name="msg">The MsgSetCardAdd message that should be simulated.</param>
		[global::System.CodeDom.Compiler.GeneratedCode("protoc-gen-cosmos-csharp", null)]
		public Task<Cosmos.Tx.V1beta1.SimulateResponse> SimulateMsgSetCardAdd(MsgSetCardAdd msg) {
			return Client.BuildAndSimulate(new Any[] {
				new Any
				{
					Value = msg.ToByteString(),
					TypeUrl = "/cardchain.cardchain.MsgSetCardAdd"
				}}
			);
		}

		/// <summary>
      	/// SimulateAndSendMsgSetCardAdd simulates, estimates fees and then sends a SetCardAdd transaction to the blockchain.
      	/// </summary>
      	/// <param name="msg">The MsgSetCardAdd message that should be send.</param>
		[global::System.CodeDom.Compiler.GeneratedCode("protoc-gen-cosmos-csharp", null)]
		public Task<Cosmcs.Client.ClientResponse<MsgSetCardAddResponse>> SimulateAndSendMsgSetCardAdd(MsgSetCardAdd msg) {
			return SimulateMsgSetCardAdd(msg).ContinueWith(r => {
				return SendMsgSetCardAdd(msg, new Cosmcs.Tx.Fee((ulong) Math.Ceiling(r.Result.GasInfo.GasUsed * 1.5))).Result;
			});
		}
        
        /// <summary>
      	/// SendMsgSetCardRemove sends a MsgSetCardRemove transaction to the blockchain and waits
      	/// for a response.
      	/// </summary>
      	/// <param name="msg">The MsgSetCardRemove message that should be send.</param>
      	/// <param name="fee">The fees that will be paid.</param>
        [global::System.CodeDom.Compiler.GeneratedCode("protoc-gen-cosmos-csharp", null)]
        public Task<Cosmcs.Client.ClientResponse<MsgSetCardRemoveResponse>> SendMsgSetCardRemove(MsgSetCardRemove msg, Cosmcs.Tx.Fee? fee = null) {
			return Client.BuildAndBroadcast(new Any[] {
				new Any
				{
					Value = msg.ToByteString(),
					TypeUrl = "/cardchain.cardchain.MsgSetCardRemove"
				}},
				fee
			).ContinueWith(r =>
			{
				var res = r.Result;
				if (res.TxResponse.Code != 0)
				{
					return res.TxResponse;
				}
				System.Threading.Thread.Sleep(13000);
				return Client.QueryTx(res.TxResponse.Txhash).Result.TxResponse;
			})
			.ContinueWith(r => new Cosmcs.Client.ClientResponse<MsgSetCardRemoveResponse>(
				r.Result,
				MsgSetCardRemoveResponse.Parser
			));
		}

		/// <summary>
      	/// SimulateMsgSetCardRemove simulates a MsgSetCardRemove transaction on the blockchain.
      	/// </summary>
      	/// <param name="msg">The MsgSetCardRemove message that should be simulated.</param>
		[global::System.CodeDom.Compiler.GeneratedCode("protoc-gen-cosmos-csharp", null)]
		public Task<Cosmos.Tx.V1beta1.SimulateResponse> SimulateMsgSetCardRemove(MsgSetCardRemove msg) {
			return Client.BuildAndSimulate(new Any[] {
				new Any
				{
					Value = msg.ToByteString(),
					TypeUrl = "/cardchain.cardchain.MsgSetCardRemove"
				}}
			);
		}

		/// <summary>
      	/// SimulateAndSendMsgSetCardRemove simulates, estimates fees and then sends a SetCardRemove transaction to the blockchain.
      	/// </summary>
      	/// <param name="msg">The MsgSetCardRemove message that should be send.</param>
		[global::System.CodeDom.Compiler.GeneratedCode("protoc-gen-cosmos-csharp", null)]
		public Task<Cosmcs.Client.ClientResponse<MsgSetCardRemoveResponse>> SimulateAndSendMsgSetCardRemove(MsgSetCardRemove msg) {
			return SimulateMsgSetCardRemove(msg).ContinueWith(r => {
				return SendMsgSetCardRemove(msg, new Cosmcs.Tx.Fee((ulong) Math.Ceiling(r.Result.GasInfo.GasUsed * 1.5))).Result;
			});
		}
        
        /// <summary>
      	/// SendMsgSetContributorAdd sends a MsgSetContributorAdd transaction to the blockchain and waits
      	/// for a response.
      	/// </summary>
      	/// <param name="msg">The MsgSetContributorAdd message that should be send.</param>
      	/// <param name="fee">The fees that will be paid.</param>
        [global::System.CodeDom.Compiler.GeneratedCode("protoc-gen-cosmos-csharp", null)]
        public Task<Cosmcs.Client.ClientResponse<MsgSetContributorAddResponse>> SendMsgSetContributorAdd(MsgSetContributorAdd msg, Cosmcs.Tx.Fee? fee = null) {
			return Client.BuildAndBroadcast(new Any[] {
				new Any
				{
					Value = msg.ToByteString(),
					TypeUrl = "/cardchain.cardchain.MsgSetContributorAdd"
				}},
				fee
			).ContinueWith(r =>
			{
				var res = r.Result;
				if (res.TxResponse.Code != 0)
				{
					return res.TxResponse;
				}
				System.Threading.Thread.Sleep(13000);
				return Client.QueryTx(res.TxResponse.Txhash).Result.TxResponse;
			})
			.ContinueWith(r => new Cosmcs.Client.ClientResponse<MsgSetContributorAddResponse>(
				r.Result,
				MsgSetContributorAddResponse.Parser
			));
		}

		/// <summary>
      	/// SimulateMsgSetContributorAdd simulates a MsgSetContributorAdd transaction on the blockchain.
      	/// </summary>
      	/// <param name="msg">The MsgSetContributorAdd message that should be simulated.</param>
		[global::System.CodeDom.Compiler.GeneratedCode("protoc-gen-cosmos-csharp", null)]
		public Task<Cosmos.Tx.V1beta1.SimulateResponse> SimulateMsgSetContributorAdd(MsgSetContributorAdd msg) {
			return Client.BuildAndSimulate(new Any[] {
				new Any
				{
					Value = msg.ToByteString(),
					TypeUrl = "/cardchain.cardchain.MsgSetContributorAdd"
				}}
			);
		}

		/// <summary>
      	/// SimulateAndSendMsgSetContributorAdd simulates, estimates fees and then sends a SetContributorAdd transaction to the blockchain.
      	/// </summary>
      	/// <param name="msg">The MsgSetContributorAdd message that should be send.</param>
		[global::System.CodeDom.Compiler.GeneratedCode("protoc-gen-cosmos-csharp", null)]
		public Task<Cosmcs.Client.ClientResponse<MsgSetContributorAddResponse>> SimulateAndSendMsgSetContributorAdd(MsgSetContributorAdd msg) {
			return SimulateMsgSetContributorAdd(msg).ContinueWith(r => {
				return SendMsgSetContributorAdd(msg, new Cosmcs.Tx.Fee((ulong) Math.Ceiling(r.Result.GasInfo.GasUsed * 1.5))).Result;
			});
		}
        
        /// <summary>
      	/// SendMsgSetContributorRemove sends a MsgSetContributorRemove transaction to the blockchain and waits
      	/// for a response.
      	/// </summary>
      	/// <param name="msg">The MsgSetContributorRemove message that should be send.</param>
      	/// <param name="fee">The fees that will be paid.</param>
        [global::System.CodeDom.Compiler.GeneratedCode("protoc-gen-cosmos-csharp", null)]
        public Task<Cosmcs.Client.ClientResponse<MsgSetContributorRemoveResponse>> SendMsgSetContributorRemove(MsgSetContributorRemove msg, Cosmcs.Tx.Fee? fee = null) {
			return Client.BuildAndBroadcast(new Any[] {
				new Any
				{
					Value = msg.ToByteString(),
					TypeUrl = "/cardchain.cardchain.MsgSetContributorRemove"
				}},
				fee
			).ContinueWith(r =>
			{
				var res = r.Result;
				if (res.TxResponse.Code != 0)
				{
					return res.TxResponse;
				}
				System.Threading.Thread.Sleep(13000);
				return Client.QueryTx(res.TxResponse.Txhash).Result.TxResponse;
			})
			.ContinueWith(r => new Cosmcs.Client.ClientResponse<MsgSetContributorRemoveResponse>(
				r.Result,
				MsgSetContributorRemoveResponse.Parser
			));
		}

		/// <summary>
      	/// SimulateMsgSetContributorRemove simulates a MsgSetContributorRemove transaction on the blockchain.
      	/// </summary>
      	/// <param name="msg">The MsgSetContributorRemove message that should be simulated.</param>
		[global::System.CodeDom.Compiler.GeneratedCode("protoc-gen-cosmos-csharp", null)]
		public Task<Cosmos.Tx.V1beta1.SimulateResponse> SimulateMsgSetContributorRemove(MsgSetContributorRemove msg) {
			return Client.BuildAndSimulate(new Any[] {
				new Any
				{
					Value = msg.ToByteString(),
					TypeUrl = "/cardchain.cardchain.MsgSetContributorRemove"
				}}
			);
		}

		/// <summary>
      	/// SimulateAndSendMsgSetContributorRemove simulates, estimates fees and then sends a SetContributorRemove transaction to the blockchain.
      	/// </summary>
      	/// <param name="msg">The MsgSetContributorRemove message that should be send.</param>
		[global::System.CodeDom.Compiler.GeneratedCode("protoc-gen-cosmos-csharp", null)]
		public Task<Cosmcs.Client.ClientResponse<MsgSetContributorRemoveResponse>> SimulateAndSendMsgSetContributorRemove(MsgSetContributorRemove msg) {
			return SimulateMsgSetContributorRemove(msg).ContinueWith(r => {
				return SendMsgSetContributorRemove(msg, new Cosmcs.Tx.Fee((ulong) Math.Ceiling(r.Result.GasInfo.GasUsed * 1.5))).Result;
			});
		}
        
        /// <summary>
      	/// SendMsgSetFinalize sends a MsgSetFinalize transaction to the blockchain and waits
      	/// for a response.
      	/// </summary>
      	/// <param name="msg">The MsgSetFinalize message that should be send.</param>
      	/// <param name="fee">The fees that will be paid.</param>
        [global::System.CodeDom.Compiler.GeneratedCode("protoc-gen-cosmos-csharp", null)]
        public Task<Cosmcs.Client.ClientResponse<MsgSetFinalizeResponse>> SendMsgSetFinalize(MsgSetFinalize msg, Cosmcs.Tx.Fee? fee = null) {
			return Client.BuildAndBroadcast(new Any[] {
				new Any
				{
					Value = msg.ToByteString(),
					TypeUrl = "/cardchain.cardchain.MsgSetFinalize"
				}},
				fee
			).ContinueWith(r =>
			{
				var res = r.Result;
				if (res.TxResponse.Code != 0)
				{
					return res.TxResponse;
				}
				System.Threading.Thread.Sleep(13000);
				return Client.QueryTx(res.TxResponse.Txhash).Result.TxResponse;
			})
			.ContinueWith(r => new Cosmcs.Client.ClientResponse<MsgSetFinalizeResponse>(
				r.Result,
				MsgSetFinalizeResponse.Parser
			));
		}

		/// <summary>
      	/// SimulateMsgSetFinalize simulates a MsgSetFinalize transaction on the blockchain.
      	/// </summary>
      	/// <param name="msg">The MsgSetFinalize message that should be simulated.</param>
		[global::System.CodeDom.Compiler.GeneratedCode("protoc-gen-cosmos-csharp", null)]
		public Task<Cosmos.Tx.V1beta1.SimulateResponse> SimulateMsgSetFinalize(MsgSetFinalize msg) {
			return Client.BuildAndSimulate(new Any[] {
				new Any
				{
					Value = msg.ToByteString(),
					TypeUrl = "/cardchain.cardchain.MsgSetFinalize"
				}}
			);
		}

		/// <summary>
      	/// SimulateAndSendMsgSetFinalize simulates, estimates fees and then sends a SetFinalize transaction to the blockchain.
      	/// </summary>
      	/// <param name="msg">The MsgSetFinalize message that should be send.</param>
		[global::System.CodeDom.Compiler.GeneratedCode("protoc-gen-cosmos-csharp", null)]
		public Task<Cosmcs.Client.ClientResponse<MsgSetFinalizeResponse>> SimulateAndSendMsgSetFinalize(MsgSetFinalize msg) {
			return SimulateMsgSetFinalize(msg).ContinueWith(r => {
				return SendMsgSetFinalize(msg, new Cosmcs.Tx.Fee((ulong) Math.Ceiling(r.Result.GasInfo.GasUsed * 1.5))).Result;
			});
		}
        
        /// <summary>
      	/// SendMsgSetArtworkAdd sends a MsgSetArtworkAdd transaction to the blockchain and waits
      	/// for a response.
      	/// </summary>
      	/// <param name="msg">The MsgSetArtworkAdd message that should be send.</param>
      	/// <param name="fee">The fees that will be paid.</param>
        [global::System.CodeDom.Compiler.GeneratedCode("protoc-gen-cosmos-csharp", null)]
        public Task<Cosmcs.Client.ClientResponse<MsgSetArtworkAddResponse>> SendMsgSetArtworkAdd(MsgSetArtworkAdd msg, Cosmcs.Tx.Fee? fee = null) {
			return Client.BuildAndBroadcast(new Any[] {
				new Any
				{
					Value = msg.ToByteString(),
					TypeUrl = "/cardchain.cardchain.MsgSetArtworkAdd"
				}},
				fee
			).ContinueWith(r =>
			{
				var res = r.Result;
				if (res.TxResponse.Code != 0)
				{
					return res.TxResponse;
				}
				System.Threading.Thread.Sleep(13000);
				return Client.QueryTx(res.TxResponse.Txhash).Result.TxResponse;
			})
			.ContinueWith(r => new Cosmcs.Client.ClientResponse<MsgSetArtworkAddResponse>(
				r.Result,
				MsgSetArtworkAddResponse.Parser
			));
		}

		/// <summary>
      	/// SimulateMsgSetArtworkAdd simulates a MsgSetArtworkAdd transaction on the blockchain.
      	/// </summary>
      	/// <param name="msg">The MsgSetArtworkAdd message that should be simulated.</param>
		[global::System.CodeDom.Compiler.GeneratedCode("protoc-gen-cosmos-csharp", null)]
		public Task<Cosmos.Tx.V1beta1.SimulateResponse> SimulateMsgSetArtworkAdd(MsgSetArtworkAdd msg) {
			return Client.BuildAndSimulate(new Any[] {
				new Any
				{
					Value = msg.ToByteString(),
					TypeUrl = "/cardchain.cardchain.MsgSetArtworkAdd"
				}}
			);
		}

		/// <summary>
      	/// SimulateAndSendMsgSetArtworkAdd simulates, estimates fees and then sends a SetArtworkAdd transaction to the blockchain.
      	/// </summary>
      	/// <param name="msg">The MsgSetArtworkAdd message that should be send.</param>
		[global::System.CodeDom.Compiler.GeneratedCode("protoc-gen-cosmos-csharp", null)]
		public Task<Cosmcs.Client.ClientResponse<MsgSetArtworkAddResponse>> SimulateAndSendMsgSetArtworkAdd(MsgSetArtworkAdd msg) {
			return SimulateMsgSetArtworkAdd(msg).ContinueWith(r => {
				return SendMsgSetArtworkAdd(msg, new Cosmcs.Tx.Fee((ulong) Math.Ceiling(r.Result.GasInfo.GasUsed * 1.5))).Result;
			});
		}
        
        /// <summary>
      	/// SendMsgSetStoryAdd sends a MsgSetStoryAdd transaction to the blockchain and waits
      	/// for a response.
      	/// </summary>
      	/// <param name="msg">The MsgSetStoryAdd message that should be send.</param>
      	/// <param name="fee">The fees that will be paid.</param>
        [global::System.CodeDom.Compiler.GeneratedCode("protoc-gen-cosmos-csharp", null)]
        public Task<Cosmcs.Client.ClientResponse<MsgSetStoryAddResponse>> SendMsgSetStoryAdd(MsgSetStoryAdd msg, Cosmcs.Tx.Fee? fee = null) {
			return Client.BuildAndBroadcast(new Any[] {
				new Any
				{
					Value = msg.ToByteString(),
					TypeUrl = "/cardchain.cardchain.MsgSetStoryAdd"
				}},
				fee
			).ContinueWith(r =>
			{
				var res = r.Result;
				if (res.TxResponse.Code != 0)
				{
					return res.TxResponse;
				}
				System.Threading.Thread.Sleep(13000);
				return Client.QueryTx(res.TxResponse.Txhash).Result.TxResponse;
			})
			.ContinueWith(r => new Cosmcs.Client.ClientResponse<MsgSetStoryAddResponse>(
				r.Result,
				MsgSetStoryAddResponse.Parser
			));
		}

		/// <summary>
      	/// SimulateMsgSetStoryAdd simulates a MsgSetStoryAdd transaction on the blockchain.
      	/// </summary>
      	/// <param name="msg">The MsgSetStoryAdd message that should be simulated.</param>
		[global::System.CodeDom.Compiler.GeneratedCode("protoc-gen-cosmos-csharp", null)]
		public Task<Cosmos.Tx.V1beta1.SimulateResponse> SimulateMsgSetStoryAdd(MsgSetStoryAdd msg) {
			return Client.BuildAndSimulate(new Any[] {
				new Any
				{
					Value = msg.ToByteString(),
					TypeUrl = "/cardchain.cardchain.MsgSetStoryAdd"
				}}
			);
		}

		/// <summary>
      	/// SimulateAndSendMsgSetStoryAdd simulates, estimates fees and then sends a SetStoryAdd transaction to the blockchain.
      	/// </summary>
      	/// <param name="msg">The MsgSetStoryAdd message that should be send.</param>
		[global::System.CodeDom.Compiler.GeneratedCode("protoc-gen-cosmos-csharp", null)]
		public Task<Cosmcs.Client.ClientResponse<MsgSetStoryAddResponse>> SimulateAndSendMsgSetStoryAdd(MsgSetStoryAdd msg) {
			return SimulateMsgSetStoryAdd(msg).ContinueWith(r => {
				return SendMsgSetStoryAdd(msg, new Cosmcs.Tx.Fee((ulong) Math.Ceiling(r.Result.GasInfo.GasUsed * 1.5))).Result;
			});
		}
        
        /// <summary>
      	/// SendMsgBoosterPackBuy sends a MsgBoosterPackBuy transaction to the blockchain and waits
      	/// for a response.
      	/// </summary>
      	/// <param name="msg">The MsgBoosterPackBuy message that should be send.</param>
      	/// <param name="fee">The fees that will be paid.</param>
        [global::System.CodeDom.Compiler.GeneratedCode("protoc-gen-cosmos-csharp", null)]
        public Task<Cosmcs.Client.ClientResponse<MsgBoosterPackBuyResponse>> SendMsgBoosterPackBuy(MsgBoosterPackBuy msg, Cosmcs.Tx.Fee? fee = null) {
			return Client.BuildAndBroadcast(new Any[] {
				new Any
				{
					Value = msg.ToByteString(),
					TypeUrl = "/cardchain.cardchain.MsgBoosterPackBuy"
				}},
				fee
			).ContinueWith(r =>
			{
				var res = r.Result;
				if (res.TxResponse.Code != 0)
				{
					return res.TxResponse;
				}
				System.Threading.Thread.Sleep(13000);
				return Client.QueryTx(res.TxResponse.Txhash).Result.TxResponse;
			})
			.ContinueWith(r => new Cosmcs.Client.ClientResponse<MsgBoosterPackBuyResponse>(
				r.Result,
				MsgBoosterPackBuyResponse.Parser
			));
		}

		/// <summary>
      	/// SimulateMsgBoosterPackBuy simulates a MsgBoosterPackBuy transaction on the blockchain.
      	/// </summary>
      	/// <param name="msg">The MsgBoosterPackBuy message that should be simulated.</param>
		[global::System.CodeDom.Compiler.GeneratedCode("protoc-gen-cosmos-csharp", null)]
		public Task<Cosmos.Tx.V1beta1.SimulateResponse> SimulateMsgBoosterPackBuy(MsgBoosterPackBuy msg) {
			return Client.BuildAndSimulate(new Any[] {
				new Any
				{
					Value = msg.ToByteString(),
					TypeUrl = "/cardchain.cardchain.MsgBoosterPackBuy"
				}}
			);
		}

		/// <summary>
      	/// SimulateAndSendMsgBoosterPackBuy simulates, estimates fees and then sends a BoosterPackBuy transaction to the blockchain.
      	/// </summary>
      	/// <param name="msg">The MsgBoosterPackBuy message that should be send.</param>
		[global::System.CodeDom.Compiler.GeneratedCode("protoc-gen-cosmos-csharp", null)]
		public Task<Cosmcs.Client.ClientResponse<MsgBoosterPackBuyResponse>> SimulateAndSendMsgBoosterPackBuy(MsgBoosterPackBuy msg) {
			return SimulateMsgBoosterPackBuy(msg).ContinueWith(r => {
				return SendMsgBoosterPackBuy(msg, new Cosmcs.Tx.Fee((ulong) Math.Ceiling(r.Result.GasInfo.GasUsed * 1.5))).Result;
			});
		}
        
        /// <summary>
      	/// SendMsgSellOfferCreate sends a MsgSellOfferCreate transaction to the blockchain and waits
      	/// for a response.
      	/// </summary>
      	/// <param name="msg">The MsgSellOfferCreate message that should be send.</param>
      	/// <param name="fee">The fees that will be paid.</param>
        [global::System.CodeDom.Compiler.GeneratedCode("protoc-gen-cosmos-csharp", null)]
        public Task<Cosmcs.Client.ClientResponse<MsgSellOfferCreateResponse>> SendMsgSellOfferCreate(MsgSellOfferCreate msg, Cosmcs.Tx.Fee? fee = null) {
			return Client.BuildAndBroadcast(new Any[] {
				new Any
				{
					Value = msg.ToByteString(),
					TypeUrl = "/cardchain.cardchain.MsgSellOfferCreate"
				}},
				fee
			).ContinueWith(r =>
			{
				var res = r.Result;
				if (res.TxResponse.Code != 0)
				{
					return res.TxResponse;
				}
				System.Threading.Thread.Sleep(13000);
				return Client.QueryTx(res.TxResponse.Txhash).Result.TxResponse;
			})
			.ContinueWith(r => new Cosmcs.Client.ClientResponse<MsgSellOfferCreateResponse>(
				r.Result,
				MsgSellOfferCreateResponse.Parser
			));
		}

		/// <summary>
      	/// SimulateMsgSellOfferCreate simulates a MsgSellOfferCreate transaction on the blockchain.
      	/// </summary>
      	/// <param name="msg">The MsgSellOfferCreate message that should be simulated.</param>
		[global::System.CodeDom.Compiler.GeneratedCode("protoc-gen-cosmos-csharp", null)]
		public Task<Cosmos.Tx.V1beta1.SimulateResponse> SimulateMsgSellOfferCreate(MsgSellOfferCreate msg) {
			return Client.BuildAndSimulate(new Any[] {
				new Any
				{
					Value = msg.ToByteString(),
					TypeUrl = "/cardchain.cardchain.MsgSellOfferCreate"
				}}
			);
		}

		/// <summary>
      	/// SimulateAndSendMsgSellOfferCreate simulates, estimates fees and then sends a SellOfferCreate transaction to the blockchain.
      	/// </summary>
      	/// <param name="msg">The MsgSellOfferCreate message that should be send.</param>
		[global::System.CodeDom.Compiler.GeneratedCode("protoc-gen-cosmos-csharp", null)]
		public Task<Cosmcs.Client.ClientResponse<MsgSellOfferCreateResponse>> SimulateAndSendMsgSellOfferCreate(MsgSellOfferCreate msg) {
			return SimulateMsgSellOfferCreate(msg).ContinueWith(r => {
				return SendMsgSellOfferCreate(msg, new Cosmcs.Tx.Fee((ulong) Math.Ceiling(r.Result.GasInfo.GasUsed * 1.5))).Result;
			});
		}
        
        /// <summary>
      	/// SendMsgSellOfferBuy sends a MsgSellOfferBuy transaction to the blockchain and waits
      	/// for a response.
      	/// </summary>
      	/// <param name="msg">The MsgSellOfferBuy message that should be send.</param>
      	/// <param name="fee">The fees that will be paid.</param>
        [global::System.CodeDom.Compiler.GeneratedCode("protoc-gen-cosmos-csharp", null)]
        public Task<Cosmcs.Client.ClientResponse<MsgSellOfferBuyResponse>> SendMsgSellOfferBuy(MsgSellOfferBuy msg, Cosmcs.Tx.Fee? fee = null) {
			return Client.BuildAndBroadcast(new Any[] {
				new Any
				{
					Value = msg.ToByteString(),
					TypeUrl = "/cardchain.cardchain.MsgSellOfferBuy"
				}},
				fee
			).ContinueWith(r =>
			{
				var res = r.Result;
				if (res.TxResponse.Code != 0)
				{
					return res.TxResponse;
				}
				System.Threading.Thread.Sleep(13000);
				return Client.QueryTx(res.TxResponse.Txhash).Result.TxResponse;
			})
			.ContinueWith(r => new Cosmcs.Client.ClientResponse<MsgSellOfferBuyResponse>(
				r.Result,
				MsgSellOfferBuyResponse.Parser
			));
		}

		/// <summary>
      	/// SimulateMsgSellOfferBuy simulates a MsgSellOfferBuy transaction on the blockchain.
      	/// </summary>
      	/// <param name="msg">The MsgSellOfferBuy message that should be simulated.</param>
		[global::System.CodeDom.Compiler.GeneratedCode("protoc-gen-cosmos-csharp", null)]
		public Task<Cosmos.Tx.V1beta1.SimulateResponse> SimulateMsgSellOfferBuy(MsgSellOfferBuy msg) {
			return Client.BuildAndSimulate(new Any[] {
				new Any
				{
					Value = msg.ToByteString(),
					TypeUrl = "/cardchain.cardchain.MsgSellOfferBuy"
				}}
			);
		}

		/// <summary>
      	/// SimulateAndSendMsgSellOfferBuy simulates, estimates fees and then sends a SellOfferBuy transaction to the blockchain.
      	/// </summary>
      	/// <param name="msg">The MsgSellOfferBuy message that should be send.</param>
		[global::System.CodeDom.Compiler.GeneratedCode("protoc-gen-cosmos-csharp", null)]
		public Task<Cosmcs.Client.ClientResponse<MsgSellOfferBuyResponse>> SimulateAndSendMsgSellOfferBuy(MsgSellOfferBuy msg) {
			return SimulateMsgSellOfferBuy(msg).ContinueWith(r => {
				return SendMsgSellOfferBuy(msg, new Cosmcs.Tx.Fee((ulong) Math.Ceiling(r.Result.GasInfo.GasUsed * 1.5))).Result;
			});
		}
        
        /// <summary>
      	/// SendMsgSellOfferRemove sends a MsgSellOfferRemove transaction to the blockchain and waits
      	/// for a response.
      	/// </summary>
      	/// <param name="msg">The MsgSellOfferRemove message that should be send.</param>
      	/// <param name="fee">The fees that will be paid.</param>
        [global::System.CodeDom.Compiler.GeneratedCode("protoc-gen-cosmos-csharp", null)]
        public Task<Cosmcs.Client.ClientResponse<MsgSellOfferRemoveResponse>> SendMsgSellOfferRemove(MsgSellOfferRemove msg, Cosmcs.Tx.Fee? fee = null) {
			return Client.BuildAndBroadcast(new Any[] {
				new Any
				{
					Value = msg.ToByteString(),
					TypeUrl = "/cardchain.cardchain.MsgSellOfferRemove"
				}},
				fee
			).ContinueWith(r =>
			{
				var res = r.Result;
				if (res.TxResponse.Code != 0)
				{
					return res.TxResponse;
				}
				System.Threading.Thread.Sleep(13000);
				return Client.QueryTx(res.TxResponse.Txhash).Result.TxResponse;
			})
			.ContinueWith(r => new Cosmcs.Client.ClientResponse<MsgSellOfferRemoveResponse>(
				r.Result,
				MsgSellOfferRemoveResponse.Parser
			));
		}

		/// <summary>
      	/// SimulateMsgSellOfferRemove simulates a MsgSellOfferRemove transaction on the blockchain.
      	/// </summary>
      	/// <param name="msg">The MsgSellOfferRemove message that should be simulated.</param>
		[global::System.CodeDom.Compiler.GeneratedCode("protoc-gen-cosmos-csharp", null)]
		public Task<Cosmos.Tx.V1beta1.SimulateResponse> SimulateMsgSellOfferRemove(MsgSellOfferRemove msg) {
			return Client.BuildAndSimulate(new Any[] {
				new Any
				{
					Value = msg.ToByteString(),
					TypeUrl = "/cardchain.cardchain.MsgSellOfferRemove"
				}}
			);
		}

		/// <summary>
      	/// SimulateAndSendMsgSellOfferRemove simulates, estimates fees and then sends a SellOfferRemove transaction to the blockchain.
      	/// </summary>
      	/// <param name="msg">The MsgSellOfferRemove message that should be send.</param>
		[global::System.CodeDom.Compiler.GeneratedCode("protoc-gen-cosmos-csharp", null)]
		public Task<Cosmcs.Client.ClientResponse<MsgSellOfferRemoveResponse>> SimulateAndSendMsgSellOfferRemove(MsgSellOfferRemove msg) {
			return SimulateMsgSellOfferRemove(msg).ContinueWith(r => {
				return SendMsgSellOfferRemove(msg, new Cosmcs.Tx.Fee((ulong) Math.Ceiling(r.Result.GasInfo.GasUsed * 1.5))).Result;
			});
		}
        
        /// <summary>
      	/// SendMsgCardRaritySet sends a MsgCardRaritySet transaction to the blockchain and waits
      	/// for a response.
      	/// </summary>
      	/// <param name="msg">The MsgCardRaritySet message that should be send.</param>
      	/// <param name="fee">The fees that will be paid.</param>
        [global::System.CodeDom.Compiler.GeneratedCode("protoc-gen-cosmos-csharp", null)]
        public Task<Cosmcs.Client.ClientResponse<MsgCardRaritySetResponse>> SendMsgCardRaritySet(MsgCardRaritySet msg, Cosmcs.Tx.Fee? fee = null) {
			return Client.BuildAndBroadcast(new Any[] {
				new Any
				{
					Value = msg.ToByteString(),
					TypeUrl = "/cardchain.cardchain.MsgCardRaritySet"
				}},
				fee
			).ContinueWith(r =>
			{
				var res = r.Result;
				if (res.TxResponse.Code != 0)
				{
					return res.TxResponse;
				}
				System.Threading.Thread.Sleep(13000);
				return Client.QueryTx(res.TxResponse.Txhash).Result.TxResponse;
			})
			.ContinueWith(r => new Cosmcs.Client.ClientResponse<MsgCardRaritySetResponse>(
				r.Result,
				MsgCardRaritySetResponse.Parser
			));
		}

		/// <summary>
      	/// SimulateMsgCardRaritySet simulates a MsgCardRaritySet transaction on the blockchain.
      	/// </summary>
      	/// <param name="msg">The MsgCardRaritySet message that should be simulated.</param>
		[global::System.CodeDom.Compiler.GeneratedCode("protoc-gen-cosmos-csharp", null)]
		public Task<Cosmos.Tx.V1beta1.SimulateResponse> SimulateMsgCardRaritySet(MsgCardRaritySet msg) {
			return Client.BuildAndSimulate(new Any[] {
				new Any
				{
					Value = msg.ToByteString(),
					TypeUrl = "/cardchain.cardchain.MsgCardRaritySet"
				}}
			);
		}

		/// <summary>
      	/// SimulateAndSendMsgCardRaritySet simulates, estimates fees and then sends a CardRaritySet transaction to the blockchain.
      	/// </summary>
      	/// <param name="msg">The MsgCardRaritySet message that should be send.</param>
		[global::System.CodeDom.Compiler.GeneratedCode("protoc-gen-cosmos-csharp", null)]
		public Task<Cosmcs.Client.ClientResponse<MsgCardRaritySetResponse>> SimulateAndSendMsgCardRaritySet(MsgCardRaritySet msg) {
			return SimulateMsgCardRaritySet(msg).ContinueWith(r => {
				return SendMsgCardRaritySet(msg, new Cosmcs.Tx.Fee((ulong) Math.Ceiling(r.Result.GasInfo.GasUsed * 1.5))).Result;
			});
		}
        
        /// <summary>
      	/// SendMsgCouncilResponseCommit sends a MsgCouncilResponseCommit transaction to the blockchain and waits
      	/// for a response.
      	/// </summary>
      	/// <param name="msg">The MsgCouncilResponseCommit message that should be send.</param>
      	/// <param name="fee">The fees that will be paid.</param>
        [global::System.CodeDom.Compiler.GeneratedCode("protoc-gen-cosmos-csharp", null)]
        public Task<Cosmcs.Client.ClientResponse<MsgCouncilResponseCommitResponse>> SendMsgCouncilResponseCommit(MsgCouncilResponseCommit msg, Cosmcs.Tx.Fee? fee = null) {
			return Client.BuildAndBroadcast(new Any[] {
				new Any
				{
					Value = msg.ToByteString(),
					TypeUrl = "/cardchain.cardchain.MsgCouncilResponseCommit"
				}},
				fee
			).ContinueWith(r =>
			{
				var res = r.Result;
				if (res.TxResponse.Code != 0)
				{
					return res.TxResponse;
				}
				System.Threading.Thread.Sleep(13000);
				return Client.QueryTx(res.TxResponse.Txhash).Result.TxResponse;
			})
			.ContinueWith(r => new Cosmcs.Client.ClientResponse<MsgCouncilResponseCommitResponse>(
				r.Result,
				MsgCouncilResponseCommitResponse.Parser
			));
		}

		/// <summary>
      	/// SimulateMsgCouncilResponseCommit simulates a MsgCouncilResponseCommit transaction on the blockchain.
      	/// </summary>
      	/// <param name="msg">The MsgCouncilResponseCommit message that should be simulated.</param>
		[global::System.CodeDom.Compiler.GeneratedCode("protoc-gen-cosmos-csharp", null)]
		public Task<Cosmos.Tx.V1beta1.SimulateResponse> SimulateMsgCouncilResponseCommit(MsgCouncilResponseCommit msg) {
			return Client.BuildAndSimulate(new Any[] {
				new Any
				{
					Value = msg.ToByteString(),
					TypeUrl = "/cardchain.cardchain.MsgCouncilResponseCommit"
				}}
			);
		}

		/// <summary>
      	/// SimulateAndSendMsgCouncilResponseCommit simulates, estimates fees and then sends a CouncilResponseCommit transaction to the blockchain.
      	/// </summary>
      	/// <param name="msg">The MsgCouncilResponseCommit message that should be send.</param>
		[global::System.CodeDom.Compiler.GeneratedCode("protoc-gen-cosmos-csharp", null)]
		public Task<Cosmcs.Client.ClientResponse<MsgCouncilResponseCommitResponse>> SimulateAndSendMsgCouncilResponseCommit(MsgCouncilResponseCommit msg) {
			return SimulateMsgCouncilResponseCommit(msg).ContinueWith(r => {
				return SendMsgCouncilResponseCommit(msg, new Cosmcs.Tx.Fee((ulong) Math.Ceiling(r.Result.GasInfo.GasUsed * 1.5))).Result;
			});
		}
        
        /// <summary>
      	/// SendMsgCouncilResponseReveal sends a MsgCouncilResponseReveal transaction to the blockchain and waits
      	/// for a response.
      	/// </summary>
      	/// <param name="msg">The MsgCouncilResponseReveal message that should be send.</param>
      	/// <param name="fee">The fees that will be paid.</param>
        [global::System.CodeDom.Compiler.GeneratedCode("protoc-gen-cosmos-csharp", null)]
        public Task<Cosmcs.Client.ClientResponse<MsgCouncilResponseRevealResponse>> SendMsgCouncilResponseReveal(MsgCouncilResponseReveal msg, Cosmcs.Tx.Fee? fee = null) {
			return Client.BuildAndBroadcast(new Any[] {
				new Any
				{
					Value = msg.ToByteString(),
					TypeUrl = "/cardchain.cardchain.MsgCouncilResponseReveal"
				}},
				fee
			).ContinueWith(r =>
			{
				var res = r.Result;
				if (res.TxResponse.Code != 0)
				{
					return res.TxResponse;
				}
				System.Threading.Thread.Sleep(13000);
				return Client.QueryTx(res.TxResponse.Txhash).Result.TxResponse;
			})
			.ContinueWith(r => new Cosmcs.Client.ClientResponse<MsgCouncilResponseRevealResponse>(
				r.Result,
				MsgCouncilResponseRevealResponse.Parser
			));
		}

		/// <summary>
      	/// SimulateMsgCouncilResponseReveal simulates a MsgCouncilResponseReveal transaction on the blockchain.
      	/// </summary>
      	/// <param name="msg">The MsgCouncilResponseReveal message that should be simulated.</param>
		[global::System.CodeDom.Compiler.GeneratedCode("protoc-gen-cosmos-csharp", null)]
		public Task<Cosmos.Tx.V1beta1.SimulateResponse> SimulateMsgCouncilResponseReveal(MsgCouncilResponseReveal msg) {
			return Client.BuildAndSimulate(new Any[] {
				new Any
				{
					Value = msg.ToByteString(),
					TypeUrl = "/cardchain.cardchain.MsgCouncilResponseReveal"
				}}
			);
		}

		/// <summary>
      	/// SimulateAndSendMsgCouncilResponseReveal simulates, estimates fees and then sends a CouncilResponseReveal transaction to the blockchain.
      	/// </summary>
      	/// <param name="msg">The MsgCouncilResponseReveal message that should be send.</param>
		[global::System.CodeDom.Compiler.GeneratedCode("protoc-gen-cosmos-csharp", null)]
		public Task<Cosmcs.Client.ClientResponse<MsgCouncilResponseRevealResponse>> SimulateAndSendMsgCouncilResponseReveal(MsgCouncilResponseReveal msg) {
			return SimulateMsgCouncilResponseReveal(msg).ContinueWith(r => {
				return SendMsgCouncilResponseReveal(msg, new Cosmcs.Tx.Fee((ulong) Math.Ceiling(r.Result.GasInfo.GasUsed * 1.5))).Result;
			});
		}
        
        /// <summary>
      	/// SendMsgCouncilRestart sends a MsgCouncilRestart transaction to the blockchain and waits
      	/// for a response.
      	/// </summary>
      	/// <param name="msg">The MsgCouncilRestart message that should be send.</param>
      	/// <param name="fee">The fees that will be paid.</param>
        [global::System.CodeDom.Compiler.GeneratedCode("protoc-gen-cosmos-csharp", null)]
        public Task<Cosmcs.Client.ClientResponse<MsgCouncilRestartResponse>> SendMsgCouncilRestart(MsgCouncilRestart msg, Cosmcs.Tx.Fee? fee = null) {
			return Client.BuildAndBroadcast(new Any[] {
				new Any
				{
					Value = msg.ToByteString(),
					TypeUrl = "/cardchain.cardchain.MsgCouncilRestart"
				}},
				fee
			).ContinueWith(r =>
			{
				var res = r.Result;
				if (res.TxResponse.Code != 0)
				{
					return res.TxResponse;
				}
				System.Threading.Thread.Sleep(13000);
				return Client.QueryTx(res.TxResponse.Txhash).Result.TxResponse;
			})
			.ContinueWith(r => new Cosmcs.Client.ClientResponse<MsgCouncilRestartResponse>(
				r.Result,
				MsgCouncilRestartResponse.Parser
			));
		}

		/// <summary>
      	/// SimulateMsgCouncilRestart simulates a MsgCouncilRestart transaction on the blockchain.
      	/// </summary>
      	/// <param name="msg">The MsgCouncilRestart message that should be simulated.</param>
		[global::System.CodeDom.Compiler.GeneratedCode("protoc-gen-cosmos-csharp", null)]
		public Task<Cosmos.Tx.V1beta1.SimulateResponse> SimulateMsgCouncilRestart(MsgCouncilRestart msg) {
			return Client.BuildAndSimulate(new Any[] {
				new Any
				{
					Value = msg.ToByteString(),
					TypeUrl = "/cardchain.cardchain.MsgCouncilRestart"
				}}
			);
		}

		/// <summary>
      	/// SimulateAndSendMsgCouncilRestart simulates, estimates fees and then sends a CouncilRestart transaction to the blockchain.
      	/// </summary>
      	/// <param name="msg">The MsgCouncilRestart message that should be send.</param>
		[global::System.CodeDom.Compiler.GeneratedCode("protoc-gen-cosmos-csharp", null)]
		public Task<Cosmcs.Client.ClientResponse<MsgCouncilRestartResponse>> SimulateAndSendMsgCouncilRestart(MsgCouncilRestart msg) {
			return SimulateMsgCouncilRestart(msg).ContinueWith(r => {
				return SendMsgCouncilRestart(msg, new Cosmcs.Tx.Fee((ulong) Math.Ceiling(r.Result.GasInfo.GasUsed * 1.5))).Result;
			});
		}
        
        /// <summary>
      	/// SendMsgMatchConfirm sends a MsgMatchConfirm transaction to the blockchain and waits
      	/// for a response.
      	/// </summary>
      	/// <param name="msg">The MsgMatchConfirm message that should be send.</param>
      	/// <param name="fee">The fees that will be paid.</param>
        [global::System.CodeDom.Compiler.GeneratedCode("protoc-gen-cosmos-csharp", null)]
        public Task<Cosmcs.Client.ClientResponse<MsgMatchConfirmResponse>> SendMsgMatchConfirm(MsgMatchConfirm msg, Cosmcs.Tx.Fee? fee = null) {
			return Client.BuildAndBroadcast(new Any[] {
				new Any
				{
					Value = msg.ToByteString(),
					TypeUrl = "/cardchain.cardchain.MsgMatchConfirm"
				}},
				fee
			).ContinueWith(r =>
			{
				var res = r.Result;
				if (res.TxResponse.Code != 0)
				{
					return res.TxResponse;
				}
				System.Threading.Thread.Sleep(13000);
				return Client.QueryTx(res.TxResponse.Txhash).Result.TxResponse;
			})
			.ContinueWith(r => new Cosmcs.Client.ClientResponse<MsgMatchConfirmResponse>(
				r.Result,
				MsgMatchConfirmResponse.Parser
			));
		}

		/// <summary>
      	/// SimulateMsgMatchConfirm simulates a MsgMatchConfirm transaction on the blockchain.
      	/// </summary>
      	/// <param name="msg">The MsgMatchConfirm message that should be simulated.</param>
		[global::System.CodeDom.Compiler.GeneratedCode("protoc-gen-cosmos-csharp", null)]
		public Task<Cosmos.Tx.V1beta1.SimulateResponse> SimulateMsgMatchConfirm(MsgMatchConfirm msg) {
			return Client.BuildAndSimulate(new Any[] {
				new Any
				{
					Value = msg.ToByteString(),
					TypeUrl = "/cardchain.cardchain.MsgMatchConfirm"
				}}
			);
		}

		/// <summary>
      	/// SimulateAndSendMsgMatchConfirm simulates, estimates fees and then sends a MatchConfirm transaction to the blockchain.
      	/// </summary>
      	/// <param name="msg">The MsgMatchConfirm message that should be send.</param>
		[global::System.CodeDom.Compiler.GeneratedCode("protoc-gen-cosmos-csharp", null)]
		public Task<Cosmcs.Client.ClientResponse<MsgMatchConfirmResponse>> SimulateAndSendMsgMatchConfirm(MsgMatchConfirm msg) {
			return SimulateMsgMatchConfirm(msg).ContinueWith(r => {
				return SendMsgMatchConfirm(msg, new Cosmcs.Tx.Fee((ulong) Math.Ceiling(r.Result.GasInfo.GasUsed * 1.5))).Result;
			});
		}
        
        /// <summary>
      	/// SendMsgProfileCardSet sends a MsgProfileCardSet transaction to the blockchain and waits
      	/// for a response.
      	/// </summary>
      	/// <param name="msg">The MsgProfileCardSet message that should be send.</param>
      	/// <param name="fee">The fees that will be paid.</param>
        [global::System.CodeDom.Compiler.GeneratedCode("protoc-gen-cosmos-csharp", null)]
        public Task<Cosmcs.Client.ClientResponse<MsgProfileCardSetResponse>> SendMsgProfileCardSet(MsgProfileCardSet msg, Cosmcs.Tx.Fee? fee = null) {
			return Client.BuildAndBroadcast(new Any[] {
				new Any
				{
					Value = msg.ToByteString(),
					TypeUrl = "/cardchain.cardchain.MsgProfileCardSet"
				}},
				fee
			).ContinueWith(r =>
			{
				var res = r.Result;
				if (res.TxResponse.Code != 0)
				{
					return res.TxResponse;
				}
				System.Threading.Thread.Sleep(13000);
				return Client.QueryTx(res.TxResponse.Txhash).Result.TxResponse;
			})
			.ContinueWith(r => new Cosmcs.Client.ClientResponse<MsgProfileCardSetResponse>(
				r.Result,
				MsgProfileCardSetResponse.Parser
			));
		}

		/// <summary>
      	/// SimulateMsgProfileCardSet simulates a MsgProfileCardSet transaction on the blockchain.
      	/// </summary>
      	/// <param name="msg">The MsgProfileCardSet message that should be simulated.</param>
		[global::System.CodeDom.Compiler.GeneratedCode("protoc-gen-cosmos-csharp", null)]
		public Task<Cosmos.Tx.V1beta1.SimulateResponse> SimulateMsgProfileCardSet(MsgProfileCardSet msg) {
			return Client.BuildAndSimulate(new Any[] {
				new Any
				{
					Value = msg.ToByteString(),
					TypeUrl = "/cardchain.cardchain.MsgProfileCardSet"
				}}
			);
		}

		/// <summary>
      	/// SimulateAndSendMsgProfileCardSet simulates, estimates fees and then sends a ProfileCardSet transaction to the blockchain.
      	/// </summary>
      	/// <param name="msg">The MsgProfileCardSet message that should be send.</param>
		[global::System.CodeDom.Compiler.GeneratedCode("protoc-gen-cosmos-csharp", null)]
		public Task<Cosmcs.Client.ClientResponse<MsgProfileCardSetResponse>> SimulateAndSendMsgProfileCardSet(MsgProfileCardSet msg) {
			return SimulateMsgProfileCardSet(msg).ContinueWith(r => {
				return SendMsgProfileCardSet(msg, new Cosmcs.Tx.Fee((ulong) Math.Ceiling(r.Result.GasInfo.GasUsed * 1.5))).Result;
			});
		}
        
        /// <summary>
      	/// SendMsgProfileWebsiteSet sends a MsgProfileWebsiteSet transaction to the blockchain and waits
      	/// for a response.
      	/// </summary>
      	/// <param name="msg">The MsgProfileWebsiteSet message that should be send.</param>
      	/// <param name="fee">The fees that will be paid.</param>
        [global::System.CodeDom.Compiler.GeneratedCode("protoc-gen-cosmos-csharp", null)]
        public Task<Cosmcs.Client.ClientResponse<MsgProfileWebsiteSetResponse>> SendMsgProfileWebsiteSet(MsgProfileWebsiteSet msg, Cosmcs.Tx.Fee? fee = null) {
			return Client.BuildAndBroadcast(new Any[] {
				new Any
				{
					Value = msg.ToByteString(),
					TypeUrl = "/cardchain.cardchain.MsgProfileWebsiteSet"
				}},
				fee
			).ContinueWith(r =>
			{
				var res = r.Result;
				if (res.TxResponse.Code != 0)
				{
					return res.TxResponse;
				}
				System.Threading.Thread.Sleep(13000);
				return Client.QueryTx(res.TxResponse.Txhash).Result.TxResponse;
			})
			.ContinueWith(r => new Cosmcs.Client.ClientResponse<MsgProfileWebsiteSetResponse>(
				r.Result,
				MsgProfileWebsiteSetResponse.Parser
			));
		}

		/// <summary>
      	/// SimulateMsgProfileWebsiteSet simulates a MsgProfileWebsiteSet transaction on the blockchain.
      	/// </summary>
      	/// <param name="msg">The MsgProfileWebsiteSet message that should be simulated.</param>
		[global::System.CodeDom.Compiler.GeneratedCode("protoc-gen-cosmos-csharp", null)]
		public Task<Cosmos.Tx.V1beta1.SimulateResponse> SimulateMsgProfileWebsiteSet(MsgProfileWebsiteSet msg) {
			return Client.BuildAndSimulate(new Any[] {
				new Any
				{
					Value = msg.ToByteString(),
					TypeUrl = "/cardchain.cardchain.MsgProfileWebsiteSet"
				}}
			);
		}

		/// <summary>
      	/// SimulateAndSendMsgProfileWebsiteSet simulates, estimates fees and then sends a ProfileWebsiteSet transaction to the blockchain.
      	/// </summary>
      	/// <param name="msg">The MsgProfileWebsiteSet message that should be send.</param>
		[global::System.CodeDom.Compiler.GeneratedCode("protoc-gen-cosmos-csharp", null)]
		public Task<Cosmcs.Client.ClientResponse<MsgProfileWebsiteSetResponse>> SimulateAndSendMsgProfileWebsiteSet(MsgProfileWebsiteSet msg) {
			return SimulateMsgProfileWebsiteSet(msg).ContinueWith(r => {
				return SendMsgProfileWebsiteSet(msg, new Cosmcs.Tx.Fee((ulong) Math.Ceiling(r.Result.GasInfo.GasUsed * 1.5))).Result;
			});
		}
        
        /// <summary>
      	/// SendMsgProfileBioSet sends a MsgProfileBioSet transaction to the blockchain and waits
      	/// for a response.
      	/// </summary>
      	/// <param name="msg">The MsgProfileBioSet message that should be send.</param>
      	/// <param name="fee">The fees that will be paid.</param>
        [global::System.CodeDom.Compiler.GeneratedCode("protoc-gen-cosmos-csharp", null)]
        public Task<Cosmcs.Client.ClientResponse<MsgProfileBioSetResponse>> SendMsgProfileBioSet(MsgProfileBioSet msg, Cosmcs.Tx.Fee? fee = null) {
			return Client.BuildAndBroadcast(new Any[] {
				new Any
				{
					Value = msg.ToByteString(),
					TypeUrl = "/cardchain.cardchain.MsgProfileBioSet"
				}},
				fee
			).ContinueWith(r =>
			{
				var res = r.Result;
				if (res.TxResponse.Code != 0)
				{
					return res.TxResponse;
				}
				System.Threading.Thread.Sleep(13000);
				return Client.QueryTx(res.TxResponse.Txhash).Result.TxResponse;
			})
			.ContinueWith(r => new Cosmcs.Client.ClientResponse<MsgProfileBioSetResponse>(
				r.Result,
				MsgProfileBioSetResponse.Parser
			));
		}

		/// <summary>
      	/// SimulateMsgProfileBioSet simulates a MsgProfileBioSet transaction on the blockchain.
      	/// </summary>
      	/// <param name="msg">The MsgProfileBioSet message that should be simulated.</param>
		[global::System.CodeDom.Compiler.GeneratedCode("protoc-gen-cosmos-csharp", null)]
		public Task<Cosmos.Tx.V1beta1.SimulateResponse> SimulateMsgProfileBioSet(MsgProfileBioSet msg) {
			return Client.BuildAndSimulate(new Any[] {
				new Any
				{
					Value = msg.ToByteString(),
					TypeUrl = "/cardchain.cardchain.MsgProfileBioSet"
				}}
			);
		}

		/// <summary>
      	/// SimulateAndSendMsgProfileBioSet simulates, estimates fees and then sends a ProfileBioSet transaction to the blockchain.
      	/// </summary>
      	/// <param name="msg">The MsgProfileBioSet message that should be send.</param>
		[global::System.CodeDom.Compiler.GeneratedCode("protoc-gen-cosmos-csharp", null)]
		public Task<Cosmcs.Client.ClientResponse<MsgProfileBioSetResponse>> SimulateAndSendMsgProfileBioSet(MsgProfileBioSet msg) {
			return SimulateMsgProfileBioSet(msg).ContinueWith(r => {
				return SendMsgProfileBioSet(msg, new Cosmcs.Tx.Fee((ulong) Math.Ceiling(r.Result.GasInfo.GasUsed * 1.5))).Result;
			});
		}
        
        /// <summary>
      	/// SendMsgBoosterPackOpen sends a MsgBoosterPackOpen transaction to the blockchain and waits
      	/// for a response.
      	/// </summary>
      	/// <param name="msg">The MsgBoosterPackOpen message that should be send.</param>
      	/// <param name="fee">The fees that will be paid.</param>
        [global::System.CodeDom.Compiler.GeneratedCode("protoc-gen-cosmos-csharp", null)]
        public Task<Cosmcs.Client.ClientResponse<MsgBoosterPackOpenResponse>> SendMsgBoosterPackOpen(MsgBoosterPackOpen msg, Cosmcs.Tx.Fee? fee = null) {
			return Client.BuildAndBroadcast(new Any[] {
				new Any
				{
					Value = msg.ToByteString(),
					TypeUrl = "/cardchain.cardchain.MsgBoosterPackOpen"
				}},
				fee
			).ContinueWith(r =>
			{
				var res = r.Result;
				if (res.TxResponse.Code != 0)
				{
					return res.TxResponse;
				}
				System.Threading.Thread.Sleep(13000);
				return Client.QueryTx(res.TxResponse.Txhash).Result.TxResponse;
			})
			.ContinueWith(r => new Cosmcs.Client.ClientResponse<MsgBoosterPackOpenResponse>(
				r.Result,
				MsgBoosterPackOpenResponse.Parser
			));
		}

		/// <summary>
      	/// SimulateMsgBoosterPackOpen simulates a MsgBoosterPackOpen transaction on the blockchain.
      	/// </summary>
      	/// <param name="msg">The MsgBoosterPackOpen message that should be simulated.</param>
		[global::System.CodeDom.Compiler.GeneratedCode("protoc-gen-cosmos-csharp", null)]
		public Task<Cosmos.Tx.V1beta1.SimulateResponse> SimulateMsgBoosterPackOpen(MsgBoosterPackOpen msg) {
			return Client.BuildAndSimulate(new Any[] {
				new Any
				{
					Value = msg.ToByteString(),
					TypeUrl = "/cardchain.cardchain.MsgBoosterPackOpen"
				}}
			);
		}

		/// <summary>
      	/// SimulateAndSendMsgBoosterPackOpen simulates, estimates fees and then sends a BoosterPackOpen transaction to the blockchain.
      	/// </summary>
      	/// <param name="msg">The MsgBoosterPackOpen message that should be send.</param>
		[global::System.CodeDom.Compiler.GeneratedCode("protoc-gen-cosmos-csharp", null)]
		public Task<Cosmcs.Client.ClientResponse<MsgBoosterPackOpenResponse>> SimulateAndSendMsgBoosterPackOpen(MsgBoosterPackOpen msg) {
			return SimulateMsgBoosterPackOpen(msg).ContinueWith(r => {
				return SendMsgBoosterPackOpen(msg, new Cosmcs.Tx.Fee((ulong) Math.Ceiling(r.Result.GasInfo.GasUsed * 1.5))).Result;
			});
		}
        
        /// <summary>
      	/// SendMsgBoosterPackTransfer sends a MsgBoosterPackTransfer transaction to the blockchain and waits
      	/// for a response.
      	/// </summary>
      	/// <param name="msg">The MsgBoosterPackTransfer message that should be send.</param>
      	/// <param name="fee">The fees that will be paid.</param>
        [global::System.CodeDom.Compiler.GeneratedCode("protoc-gen-cosmos-csharp", null)]
        public Task<Cosmcs.Client.ClientResponse<MsgBoosterPackTransferResponse>> SendMsgBoosterPackTransfer(MsgBoosterPackTransfer msg, Cosmcs.Tx.Fee? fee = null) {
			return Client.BuildAndBroadcast(new Any[] {
				new Any
				{
					Value = msg.ToByteString(),
					TypeUrl = "/cardchain.cardchain.MsgBoosterPackTransfer"
				}},
				fee
			).ContinueWith(r =>
			{
				var res = r.Result;
				if (res.TxResponse.Code != 0)
				{
					return res.TxResponse;
				}
				System.Threading.Thread.Sleep(13000);
				return Client.QueryTx(res.TxResponse.Txhash).Result.TxResponse;
			})
			.ContinueWith(r => new Cosmcs.Client.ClientResponse<MsgBoosterPackTransferResponse>(
				r.Result,
				MsgBoosterPackTransferResponse.Parser
			));
		}

		/// <summary>
      	/// SimulateMsgBoosterPackTransfer simulates a MsgBoosterPackTransfer transaction on the blockchain.
      	/// </summary>
      	/// <param name="msg">The MsgBoosterPackTransfer message that should be simulated.</param>
		[global::System.CodeDom.Compiler.GeneratedCode("protoc-gen-cosmos-csharp", null)]
		public Task<Cosmos.Tx.V1beta1.SimulateResponse> SimulateMsgBoosterPackTransfer(MsgBoosterPackTransfer msg) {
			return Client.BuildAndSimulate(new Any[] {
				new Any
				{
					Value = msg.ToByteString(),
					TypeUrl = "/cardchain.cardchain.MsgBoosterPackTransfer"
				}}
			);
		}

		/// <summary>
      	/// SimulateAndSendMsgBoosterPackTransfer simulates, estimates fees and then sends a BoosterPackTransfer transaction to the blockchain.
      	/// </summary>
      	/// <param name="msg">The MsgBoosterPackTransfer message that should be send.</param>
		[global::System.CodeDom.Compiler.GeneratedCode("protoc-gen-cosmos-csharp", null)]
		public Task<Cosmcs.Client.ClientResponse<MsgBoosterPackTransferResponse>> SimulateAndSendMsgBoosterPackTransfer(MsgBoosterPackTransfer msg) {
			return SimulateMsgBoosterPackTransfer(msg).ContinueWith(r => {
				return SendMsgBoosterPackTransfer(msg, new Cosmcs.Tx.Fee((ulong) Math.Ceiling(r.Result.GasInfo.GasUsed * 1.5))).Result;
			});
		}
        
        /// <summary>
      	/// SendMsgSetStoryWriterSet sends a MsgSetStoryWriterSet transaction to the blockchain and waits
      	/// for a response.
      	/// </summary>
      	/// <param name="msg">The MsgSetStoryWriterSet message that should be send.</param>
      	/// <param name="fee">The fees that will be paid.</param>
        [global::System.CodeDom.Compiler.GeneratedCode("protoc-gen-cosmos-csharp", null)]
        public Task<Cosmcs.Client.ClientResponse<MsgSetStoryWriterSetResponse>> SendMsgSetStoryWriterSet(MsgSetStoryWriterSet msg, Cosmcs.Tx.Fee? fee = null) {
			return Client.BuildAndBroadcast(new Any[] {
				new Any
				{
					Value = msg.ToByteString(),
					TypeUrl = "/cardchain.cardchain.MsgSetStoryWriterSet"
				}},
				fee
			).ContinueWith(r =>
			{
				var res = r.Result;
				if (res.TxResponse.Code != 0)
				{
					return res.TxResponse;
				}
				System.Threading.Thread.Sleep(13000);
				return Client.QueryTx(res.TxResponse.Txhash).Result.TxResponse;
			})
			.ContinueWith(r => new Cosmcs.Client.ClientResponse<MsgSetStoryWriterSetResponse>(
				r.Result,
				MsgSetStoryWriterSetResponse.Parser
			));
		}

		/// <summary>
      	/// SimulateMsgSetStoryWriterSet simulates a MsgSetStoryWriterSet transaction on the blockchain.
      	/// </summary>
      	/// <param name="msg">The MsgSetStoryWriterSet message that should be simulated.</param>
		[global::System.CodeDom.Compiler.GeneratedCode("protoc-gen-cosmos-csharp", null)]
		public Task<Cosmos.Tx.V1beta1.SimulateResponse> SimulateMsgSetStoryWriterSet(MsgSetStoryWriterSet msg) {
			return Client.BuildAndSimulate(new Any[] {
				new Any
				{
					Value = msg.ToByteString(),
					TypeUrl = "/cardchain.cardchain.MsgSetStoryWriterSet"
				}}
			);
		}

		/// <summary>
      	/// SimulateAndSendMsgSetStoryWriterSet simulates, estimates fees and then sends a SetStoryWriterSet transaction to the blockchain.
      	/// </summary>
      	/// <param name="msg">The MsgSetStoryWriterSet message that should be send.</param>
		[global::System.CodeDom.Compiler.GeneratedCode("protoc-gen-cosmos-csharp", null)]
		public Task<Cosmcs.Client.ClientResponse<MsgSetStoryWriterSetResponse>> SimulateAndSendMsgSetStoryWriterSet(MsgSetStoryWriterSet msg) {
			return SimulateMsgSetStoryWriterSet(msg).ContinueWith(r => {
				return SendMsgSetStoryWriterSet(msg, new Cosmcs.Tx.Fee((ulong) Math.Ceiling(r.Result.GasInfo.GasUsed * 1.5))).Result;
			});
		}
        
        /// <summary>
      	/// SendMsgSetArtistSet sends a MsgSetArtistSet transaction to the blockchain and waits
      	/// for a response.
      	/// </summary>
      	/// <param name="msg">The MsgSetArtistSet message that should be send.</param>
      	/// <param name="fee">The fees that will be paid.</param>
        [global::System.CodeDom.Compiler.GeneratedCode("protoc-gen-cosmos-csharp", null)]
        public Task<Cosmcs.Client.ClientResponse<MsgSetArtistSetResponse>> SendMsgSetArtistSet(MsgSetArtistSet msg, Cosmcs.Tx.Fee? fee = null) {
			return Client.BuildAndBroadcast(new Any[] {
				new Any
				{
					Value = msg.ToByteString(),
					TypeUrl = "/cardchain.cardchain.MsgSetArtistSet"
				}},
				fee
			).ContinueWith(r =>
			{
				var res = r.Result;
				if (res.TxResponse.Code != 0)
				{
					return res.TxResponse;
				}
				System.Threading.Thread.Sleep(13000);
				return Client.QueryTx(res.TxResponse.Txhash).Result.TxResponse;
			})
			.ContinueWith(r => new Cosmcs.Client.ClientResponse<MsgSetArtistSetResponse>(
				r.Result,
				MsgSetArtistSetResponse.Parser
			));
		}

		/// <summary>
      	/// SimulateMsgSetArtistSet simulates a MsgSetArtistSet transaction on the blockchain.
      	/// </summary>
      	/// <param name="msg">The MsgSetArtistSet message that should be simulated.</param>
		[global::System.CodeDom.Compiler.GeneratedCode("protoc-gen-cosmos-csharp", null)]
		public Task<Cosmos.Tx.V1beta1.SimulateResponse> SimulateMsgSetArtistSet(MsgSetArtistSet msg) {
			return Client.BuildAndSimulate(new Any[] {
				new Any
				{
					Value = msg.ToByteString(),
					TypeUrl = "/cardchain.cardchain.MsgSetArtistSet"
				}}
			);
		}

		/// <summary>
      	/// SimulateAndSendMsgSetArtistSet simulates, estimates fees and then sends a SetArtistSet transaction to the blockchain.
      	/// </summary>
      	/// <param name="msg">The MsgSetArtistSet message that should be send.</param>
		[global::System.CodeDom.Compiler.GeneratedCode("protoc-gen-cosmos-csharp", null)]
		public Task<Cosmcs.Client.ClientResponse<MsgSetArtistSetResponse>> SimulateAndSendMsgSetArtistSet(MsgSetArtistSet msg) {
			return SimulateMsgSetArtistSet(msg).ContinueWith(r => {
				return SendMsgSetArtistSet(msg, new Cosmcs.Tx.Fee((ulong) Math.Ceiling(r.Result.GasInfo.GasUsed * 1.5))).Result;
			});
		}
        
        /// <summary>
      	/// SendMsgCardVoteMulti sends a MsgCardVoteMulti transaction to the blockchain and waits
      	/// for a response.
      	/// </summary>
      	/// <param name="msg">The MsgCardVoteMulti message that should be send.</param>
      	/// <param name="fee">The fees that will be paid.</param>
        [global::System.CodeDom.Compiler.GeneratedCode("protoc-gen-cosmos-csharp", null)]
        public Task<Cosmcs.Client.ClientResponse<MsgCardVoteMultiResponse>> SendMsgCardVoteMulti(MsgCardVoteMulti msg, Cosmcs.Tx.Fee? fee = null) {
			return Client.BuildAndBroadcast(new Any[] {
				new Any
				{
					Value = msg.ToByteString(),
					TypeUrl = "/cardchain.cardchain.MsgCardVoteMulti"
				}},
				fee
			).ContinueWith(r =>
			{
				var res = r.Result;
				if (res.TxResponse.Code != 0)
				{
					return res.TxResponse;
				}
				System.Threading.Thread.Sleep(13000);
				return Client.QueryTx(res.TxResponse.Txhash).Result.TxResponse;
			})
			.ContinueWith(r => new Cosmcs.Client.ClientResponse<MsgCardVoteMultiResponse>(
				r.Result,
				MsgCardVoteMultiResponse.Parser
			));
		}

		/// <summary>
      	/// SimulateMsgCardVoteMulti simulates a MsgCardVoteMulti transaction on the blockchain.
      	/// </summary>
      	/// <param name="msg">The MsgCardVoteMulti message that should be simulated.</param>
		[global::System.CodeDom.Compiler.GeneratedCode("protoc-gen-cosmos-csharp", null)]
		public Task<Cosmos.Tx.V1beta1.SimulateResponse> SimulateMsgCardVoteMulti(MsgCardVoteMulti msg) {
			return Client.BuildAndSimulate(new Any[] {
				new Any
				{
					Value = msg.ToByteString(),
					TypeUrl = "/cardchain.cardchain.MsgCardVoteMulti"
				}}
			);
		}

		/// <summary>
      	/// SimulateAndSendMsgCardVoteMulti simulates, estimates fees and then sends a CardVoteMulti transaction to the blockchain.
      	/// </summary>
      	/// <param name="msg">The MsgCardVoteMulti message that should be send.</param>
		[global::System.CodeDom.Compiler.GeneratedCode("protoc-gen-cosmos-csharp", null)]
		public Task<Cosmcs.Client.ClientResponse<MsgCardVoteMultiResponse>> SimulateAndSendMsgCardVoteMulti(MsgCardVoteMulti msg) {
			return SimulateMsgCardVoteMulti(msg).ContinueWith(r => {
				return SendMsgCardVoteMulti(msg, new Cosmcs.Tx.Fee((ulong) Math.Ceiling(r.Result.GasInfo.GasUsed * 1.5))).Result;
			});
		}
        
        /// <summary>
      	/// SendMsgMatchOpen sends a MsgMatchOpen transaction to the blockchain and waits
      	/// for a response.
      	/// </summary>
      	/// <param name="msg">The MsgMatchOpen message that should be send.</param>
      	/// <param name="fee">The fees that will be paid.</param>
        [global::System.CodeDom.Compiler.GeneratedCode("protoc-gen-cosmos-csharp", null)]
        public Task<Cosmcs.Client.ClientResponse<MsgMatchOpenResponse>> SendMsgMatchOpen(MsgMatchOpen msg, Cosmcs.Tx.Fee? fee = null) {
			return Client.BuildAndBroadcast(new Any[] {
				new Any
				{
					Value = msg.ToByteString(),
					TypeUrl = "/cardchain.cardchain.MsgMatchOpen"
				}},
				fee
			).ContinueWith(r =>
			{
				var res = r.Result;
				if (res.TxResponse.Code != 0)
				{
					return res.TxResponse;
				}
				System.Threading.Thread.Sleep(13000);
				return Client.QueryTx(res.TxResponse.Txhash).Result.TxResponse;
			})
			.ContinueWith(r => new Cosmcs.Client.ClientResponse<MsgMatchOpenResponse>(
				r.Result,
				MsgMatchOpenResponse.Parser
			));
		}

		/// <summary>
      	/// SimulateMsgMatchOpen simulates a MsgMatchOpen transaction on the blockchain.
      	/// </summary>
      	/// <param name="msg">The MsgMatchOpen message that should be simulated.</param>
		[global::System.CodeDom.Compiler.GeneratedCode("protoc-gen-cosmos-csharp", null)]
		public Task<Cosmos.Tx.V1beta1.SimulateResponse> SimulateMsgMatchOpen(MsgMatchOpen msg) {
			return Client.BuildAndSimulate(new Any[] {
				new Any
				{
					Value = msg.ToByteString(),
					TypeUrl = "/cardchain.cardchain.MsgMatchOpen"
				}}
			);
		}

		/// <summary>
      	/// SimulateAndSendMsgMatchOpen simulates, estimates fees and then sends a MatchOpen transaction to the blockchain.
      	/// </summary>
      	/// <param name="msg">The MsgMatchOpen message that should be send.</param>
		[global::System.CodeDom.Compiler.GeneratedCode("protoc-gen-cosmos-csharp", null)]
		public Task<Cosmcs.Client.ClientResponse<MsgMatchOpenResponse>> SimulateAndSendMsgMatchOpen(MsgMatchOpen msg) {
			return SimulateMsgMatchOpen(msg).ContinueWith(r => {
				return SendMsgMatchOpen(msg, new Cosmcs.Tx.Fee((ulong) Math.Ceiling(r.Result.GasInfo.GasUsed * 1.5))).Result;
			});
		}
        
        /// <summary>
      	/// SendMsgSetNameSet sends a MsgSetNameSet transaction to the blockchain and waits
      	/// for a response.
      	/// </summary>
      	/// <param name="msg">The MsgSetNameSet message that should be send.</param>
      	/// <param name="fee">The fees that will be paid.</param>
        [global::System.CodeDom.Compiler.GeneratedCode("protoc-gen-cosmos-csharp", null)]
        public Task<Cosmcs.Client.ClientResponse<MsgSetNameSetResponse>> SendMsgSetNameSet(MsgSetNameSet msg, Cosmcs.Tx.Fee? fee = null) {
			return Client.BuildAndBroadcast(new Any[] {
				new Any
				{
					Value = msg.ToByteString(),
					TypeUrl = "/cardchain.cardchain.MsgSetNameSet"
				}},
				fee
			).ContinueWith(r =>
			{
				var res = r.Result;
				if (res.TxResponse.Code != 0)
				{
					return res.TxResponse;
				}
				System.Threading.Thread.Sleep(13000);
				return Client.QueryTx(res.TxResponse.Txhash).Result.TxResponse;
			})
			.ContinueWith(r => new Cosmcs.Client.ClientResponse<MsgSetNameSetResponse>(
				r.Result,
				MsgSetNameSetResponse.Parser
			));
		}

		/// <summary>
      	/// SimulateMsgSetNameSet simulates a MsgSetNameSet transaction on the blockchain.
      	/// </summary>
      	/// <param name="msg">The MsgSetNameSet message that should be simulated.</param>
		[global::System.CodeDom.Compiler.GeneratedCode("protoc-gen-cosmos-csharp", null)]
		public Task<Cosmos.Tx.V1beta1.SimulateResponse> SimulateMsgSetNameSet(MsgSetNameSet msg) {
			return Client.BuildAndSimulate(new Any[] {
				new Any
				{
					Value = msg.ToByteString(),
					TypeUrl = "/cardchain.cardchain.MsgSetNameSet"
				}}
			);
		}

		/// <summary>
      	/// SimulateAndSendMsgSetNameSet simulates, estimates fees and then sends a SetNameSet transaction to the blockchain.
      	/// </summary>
      	/// <param name="msg">The MsgSetNameSet message that should be send.</param>
		[global::System.CodeDom.Compiler.GeneratedCode("protoc-gen-cosmos-csharp", null)]
		public Task<Cosmcs.Client.ClientResponse<MsgSetNameSetResponse>> SimulateAndSendMsgSetNameSet(MsgSetNameSet msg) {
			return SimulateMsgSetNameSet(msg).ContinueWith(r => {
				return SendMsgSetNameSet(msg, new Cosmcs.Tx.Fee((ulong) Math.Ceiling(r.Result.GasInfo.GasUsed * 1.5))).Result;
			});
		}
        
        /// <summary>
      	/// SendMsgProfileAliasSet sends a MsgProfileAliasSet transaction to the blockchain and waits
      	/// for a response.
      	/// </summary>
      	/// <param name="msg">The MsgProfileAliasSet message that should be send.</param>
      	/// <param name="fee">The fees that will be paid.</param>
        [global::System.CodeDom.Compiler.GeneratedCode("protoc-gen-cosmos-csharp", null)]
        public Task<Cosmcs.Client.ClientResponse<MsgProfileAliasSetResponse>> SendMsgProfileAliasSet(MsgProfileAliasSet msg, Cosmcs.Tx.Fee? fee = null) {
			return Client.BuildAndBroadcast(new Any[] {
				new Any
				{
					Value = msg.ToByteString(),
					TypeUrl = "/cardchain.cardchain.MsgProfileAliasSet"
				}},
				fee
			).ContinueWith(r =>
			{
				var res = r.Result;
				if (res.TxResponse.Code != 0)
				{
					return res.TxResponse;
				}
				System.Threading.Thread.Sleep(13000);
				return Client.QueryTx(res.TxResponse.Txhash).Result.TxResponse;
			})
			.ContinueWith(r => new Cosmcs.Client.ClientResponse<MsgProfileAliasSetResponse>(
				r.Result,
				MsgProfileAliasSetResponse.Parser
			));
		}

		/// <summary>
      	/// SimulateMsgProfileAliasSet simulates a MsgProfileAliasSet transaction on the blockchain.
      	/// </summary>
      	/// <param name="msg">The MsgProfileAliasSet message that should be simulated.</param>
		[global::System.CodeDom.Compiler.GeneratedCode("protoc-gen-cosmos-csharp", null)]
		public Task<Cosmos.Tx.V1beta1.SimulateResponse> SimulateMsgProfileAliasSet(MsgProfileAliasSet msg) {
			return Client.BuildAndSimulate(new Any[] {
				new Any
				{
					Value = msg.ToByteString(),
					TypeUrl = "/cardchain.cardchain.MsgProfileAliasSet"
				}}
			);
		}

		/// <summary>
      	/// SimulateAndSendMsgProfileAliasSet simulates, estimates fees and then sends a ProfileAliasSet transaction to the blockchain.
      	/// </summary>
      	/// <param name="msg">The MsgProfileAliasSet message that should be send.</param>
		[global::System.CodeDom.Compiler.GeneratedCode("protoc-gen-cosmos-csharp", null)]
		public Task<Cosmcs.Client.ClientResponse<MsgProfileAliasSetResponse>> SimulateAndSendMsgProfileAliasSet(MsgProfileAliasSet msg) {
			return SimulateMsgProfileAliasSet(msg).ContinueWith(r => {
				return SendMsgProfileAliasSet(msg, new Cosmcs.Tx.Fee((ulong) Math.Ceiling(r.Result.GasInfo.GasUsed * 1.5))).Result;
			});
		}
        
        /// <summary>
      	/// SendMsgEarlyAccessInvite sends a MsgEarlyAccessInvite transaction to the blockchain and waits
      	/// for a response.
      	/// </summary>
      	/// <param name="msg">The MsgEarlyAccessInvite message that should be send.</param>
      	/// <param name="fee">The fees that will be paid.</param>
        [global::System.CodeDom.Compiler.GeneratedCode("protoc-gen-cosmos-csharp", null)]
        public Task<Cosmcs.Client.ClientResponse<MsgEarlyAccessInviteResponse>> SendMsgEarlyAccessInvite(MsgEarlyAccessInvite msg, Cosmcs.Tx.Fee? fee = null) {
			return Client.BuildAndBroadcast(new Any[] {
				new Any
				{
					Value = msg.ToByteString(),
					TypeUrl = "/cardchain.cardchain.MsgEarlyAccessInvite"
				}},
				fee
			).ContinueWith(r =>
			{
				var res = r.Result;
				if (res.TxResponse.Code != 0)
				{
					return res.TxResponse;
				}
				System.Threading.Thread.Sleep(13000);
				return Client.QueryTx(res.TxResponse.Txhash).Result.TxResponse;
			})
			.ContinueWith(r => new Cosmcs.Client.ClientResponse<MsgEarlyAccessInviteResponse>(
				r.Result,
				MsgEarlyAccessInviteResponse.Parser
			));
		}

		/// <summary>
      	/// SimulateMsgEarlyAccessInvite simulates a MsgEarlyAccessInvite transaction on the blockchain.
      	/// </summary>
      	/// <param name="msg">The MsgEarlyAccessInvite message that should be simulated.</param>
		[global::System.CodeDom.Compiler.GeneratedCode("protoc-gen-cosmos-csharp", null)]
		public Task<Cosmos.Tx.V1beta1.SimulateResponse> SimulateMsgEarlyAccessInvite(MsgEarlyAccessInvite msg) {
			return Client.BuildAndSimulate(new Any[] {
				new Any
				{
					Value = msg.ToByteString(),
					TypeUrl = "/cardchain.cardchain.MsgEarlyAccessInvite"
				}}
			);
		}

		/// <summary>
      	/// SimulateAndSendMsgEarlyAccessInvite simulates, estimates fees and then sends a EarlyAccessInvite transaction to the blockchain.
      	/// </summary>
      	/// <param name="msg">The MsgEarlyAccessInvite message that should be send.</param>
		[global::System.CodeDom.Compiler.GeneratedCode("protoc-gen-cosmos-csharp", null)]
		public Task<Cosmcs.Client.ClientResponse<MsgEarlyAccessInviteResponse>> SimulateAndSendMsgEarlyAccessInvite(MsgEarlyAccessInvite msg) {
			return SimulateMsgEarlyAccessInvite(msg).ContinueWith(r => {
				return SendMsgEarlyAccessInvite(msg, new Cosmcs.Tx.Fee((ulong) Math.Ceiling(r.Result.GasInfo.GasUsed * 1.5))).Result;
			});
		}
        
        /// <summary>
      	/// SendMsgZealyConnect sends a MsgZealyConnect transaction to the blockchain and waits
      	/// for a response.
      	/// </summary>
      	/// <param name="msg">The MsgZealyConnect message that should be send.</param>
      	/// <param name="fee">The fees that will be paid.</param>
        [global::System.CodeDom.Compiler.GeneratedCode("protoc-gen-cosmos-csharp", null)]
        public Task<Cosmcs.Client.ClientResponse<MsgZealyConnectResponse>> SendMsgZealyConnect(MsgZealyConnect msg, Cosmcs.Tx.Fee? fee = null) {
			return Client.BuildAndBroadcast(new Any[] {
				new Any
				{
					Value = msg.ToByteString(),
					TypeUrl = "/cardchain.cardchain.MsgZealyConnect"
				}},
				fee
			).ContinueWith(r =>
			{
				var res = r.Result;
				if (res.TxResponse.Code != 0)
				{
					return res.TxResponse;
				}
				System.Threading.Thread.Sleep(13000);
				return Client.QueryTx(res.TxResponse.Txhash).Result.TxResponse;
			})
			.ContinueWith(r => new Cosmcs.Client.ClientResponse<MsgZealyConnectResponse>(
				r.Result,
				MsgZealyConnectResponse.Parser
			));
		}

		/// <summary>
      	/// SimulateMsgZealyConnect simulates a MsgZealyConnect transaction on the blockchain.
      	/// </summary>
      	/// <param name="msg">The MsgZealyConnect message that should be simulated.</param>
		[global::System.CodeDom.Compiler.GeneratedCode("protoc-gen-cosmos-csharp", null)]
		public Task<Cosmos.Tx.V1beta1.SimulateResponse> SimulateMsgZealyConnect(MsgZealyConnect msg) {
			return Client.BuildAndSimulate(new Any[] {
				new Any
				{
					Value = msg.ToByteString(),
					TypeUrl = "/cardchain.cardchain.MsgZealyConnect"
				}}
			);
		}

		/// <summary>
      	/// SimulateAndSendMsgZealyConnect simulates, estimates fees and then sends a ZealyConnect transaction to the blockchain.
      	/// </summary>
      	/// <param name="msg">The MsgZealyConnect message that should be send.</param>
		[global::System.CodeDom.Compiler.GeneratedCode("protoc-gen-cosmos-csharp", null)]
		public Task<Cosmcs.Client.ClientResponse<MsgZealyConnectResponse>> SimulateAndSendMsgZealyConnect(MsgZealyConnect msg) {
			return SimulateMsgZealyConnect(msg).ContinueWith(r => {
				return SendMsgZealyConnect(msg, new Cosmcs.Tx.Fee((ulong) Math.Ceiling(r.Result.GasInfo.GasUsed * 1.5))).Result;
			});
		}
        
        /// <summary>
      	/// SendMsgEncounterCreate sends a MsgEncounterCreate transaction to the blockchain and waits
      	/// for a response.
      	/// </summary>
      	/// <param name="msg">The MsgEncounterCreate message that should be send.</param>
      	/// <param name="fee">The fees that will be paid.</param>
        [global::System.CodeDom.Compiler.GeneratedCode("protoc-gen-cosmos-csharp", null)]
        public Task<Cosmcs.Client.ClientResponse<MsgEncounterCreateResponse>> SendMsgEncounterCreate(MsgEncounterCreate msg, Cosmcs.Tx.Fee? fee = null) {
			return Client.BuildAndBroadcast(new Any[] {
				new Any
				{
					Value = msg.ToByteString(),
					TypeUrl = "/cardchain.cardchain.MsgEncounterCreate"
				}},
				fee
			).ContinueWith(r =>
			{
				var res = r.Result;
				if (res.TxResponse.Code != 0)
				{
					return res.TxResponse;
				}
				System.Threading.Thread.Sleep(13000);
				return Client.QueryTx(res.TxResponse.Txhash).Result.TxResponse;
			})
			.ContinueWith(r => new Cosmcs.Client.ClientResponse<MsgEncounterCreateResponse>(
				r.Result,
				MsgEncounterCreateResponse.Parser
			));
		}

		/// <summary>
      	/// SimulateMsgEncounterCreate simulates a MsgEncounterCreate transaction on the blockchain.
      	/// </summary>
      	/// <param name="msg">The MsgEncounterCreate message that should be simulated.</param>
		[global::System.CodeDom.Compiler.GeneratedCode("protoc-gen-cosmos-csharp", null)]
		public Task<Cosmos.Tx.V1beta1.SimulateResponse> SimulateMsgEncounterCreate(MsgEncounterCreate msg) {
			return Client.BuildAndSimulate(new Any[] {
				new Any
				{
					Value = msg.ToByteString(),
					TypeUrl = "/cardchain.cardchain.MsgEncounterCreate"
				}}
			);
		}

		/// <summary>
      	/// SimulateAndSendMsgEncounterCreate simulates, estimates fees and then sends a EncounterCreate transaction to the blockchain.
      	/// </summary>
      	/// <param name="msg">The MsgEncounterCreate message that should be send.</param>
		[global::System.CodeDom.Compiler.GeneratedCode("protoc-gen-cosmos-csharp", null)]
		public Task<Cosmcs.Client.ClientResponse<MsgEncounterCreateResponse>> SimulateAndSendMsgEncounterCreate(MsgEncounterCreate msg) {
			return SimulateMsgEncounterCreate(msg).ContinueWith(r => {
				return SendMsgEncounterCreate(msg, new Cosmcs.Tx.Fee((ulong) Math.Ceiling(r.Result.GasInfo.GasUsed * 1.5))).Result;
			});
		}
        
        /// <summary>
      	/// SendMsgEncounterDo sends a MsgEncounterDo transaction to the blockchain and waits
      	/// for a response.
      	/// </summary>
      	/// <param name="msg">The MsgEncounterDo message that should be send.</param>
      	/// <param name="fee">The fees that will be paid.</param>
        [global::System.CodeDom.Compiler.GeneratedCode("protoc-gen-cosmos-csharp", null)]
        public Task<Cosmcs.Client.ClientResponse<MsgEncounterDoResponse>> SendMsgEncounterDo(MsgEncounterDo msg, Cosmcs.Tx.Fee? fee = null) {
			return Client.BuildAndBroadcast(new Any[] {
				new Any
				{
					Value = msg.ToByteString(),
					TypeUrl = "/cardchain.cardchain.MsgEncounterDo"
				}},
				fee
			).ContinueWith(r =>
			{
				var res = r.Result;
				if (res.TxResponse.Code != 0)
				{
					return res.TxResponse;
				}
				System.Threading.Thread.Sleep(13000);
				return Client.QueryTx(res.TxResponse.Txhash).Result.TxResponse;
			})
			.ContinueWith(r => new Cosmcs.Client.ClientResponse<MsgEncounterDoResponse>(
				r.Result,
				MsgEncounterDoResponse.Parser
			));
		}

		/// <summary>
      	/// SimulateMsgEncounterDo simulates a MsgEncounterDo transaction on the blockchain.
      	/// </summary>
      	/// <param name="msg">The MsgEncounterDo message that should be simulated.</param>
		[global::System.CodeDom.Compiler.GeneratedCode("protoc-gen-cosmos-csharp", null)]
		public Task<Cosmos.Tx.V1beta1.SimulateResponse> SimulateMsgEncounterDo(MsgEncounterDo msg) {
			return Client.BuildAndSimulate(new Any[] {
				new Any
				{
					Value = msg.ToByteString(),
					TypeUrl = "/cardchain.cardchain.MsgEncounterDo"
				}}
			);
		}

		/// <summary>
      	/// SimulateAndSendMsgEncounterDo simulates, estimates fees and then sends a EncounterDo transaction to the blockchain.
      	/// </summary>
      	/// <param name="msg">The MsgEncounterDo message that should be send.</param>
		[global::System.CodeDom.Compiler.GeneratedCode("protoc-gen-cosmos-csharp", null)]
		public Task<Cosmcs.Client.ClientResponse<MsgEncounterDoResponse>> SimulateAndSendMsgEncounterDo(MsgEncounterDo msg) {
			return SimulateMsgEncounterDo(msg).ContinueWith(r => {
				return SendMsgEncounterDo(msg, new Cosmcs.Tx.Fee((ulong) Math.Ceiling(r.Result.GasInfo.GasUsed * 1.5))).Result;
			});
		}
        
        /// <summary>
      	/// SendMsgEncounterClose sends a MsgEncounterClose transaction to the blockchain and waits
      	/// for a response.
      	/// </summary>
      	/// <param name="msg">The MsgEncounterClose message that should be send.</param>
      	/// <param name="fee">The fees that will be paid.</param>
        [global::System.CodeDom.Compiler.GeneratedCode("protoc-gen-cosmos-csharp", null)]
        public Task<Cosmcs.Client.ClientResponse<MsgEncounterCloseResponse>> SendMsgEncounterClose(MsgEncounterClose msg, Cosmcs.Tx.Fee? fee = null) {
			return Client.BuildAndBroadcast(new Any[] {
				new Any
				{
					Value = msg.ToByteString(),
					TypeUrl = "/cardchain.cardchain.MsgEncounterClose"
				}},
				fee
			).ContinueWith(r =>
			{
				var res = r.Result;
				if (res.TxResponse.Code != 0)
				{
					return res.TxResponse;
				}
				System.Threading.Thread.Sleep(13000);
				return Client.QueryTx(res.TxResponse.Txhash).Result.TxResponse;
			})
			.ContinueWith(r => new Cosmcs.Client.ClientResponse<MsgEncounterCloseResponse>(
				r.Result,
				MsgEncounterCloseResponse.Parser
			));
		}

		/// <summary>
      	/// SimulateMsgEncounterClose simulates a MsgEncounterClose transaction on the blockchain.
      	/// </summary>
      	/// <param name="msg">The MsgEncounterClose message that should be simulated.</param>
		[global::System.CodeDom.Compiler.GeneratedCode("protoc-gen-cosmos-csharp", null)]
		public Task<Cosmos.Tx.V1beta1.SimulateResponse> SimulateMsgEncounterClose(MsgEncounterClose msg) {
			return Client.BuildAndSimulate(new Any[] {
				new Any
				{
					Value = msg.ToByteString(),
					TypeUrl = "/cardchain.cardchain.MsgEncounterClose"
				}}
			);
		}

		/// <summary>
      	/// SimulateAndSendMsgEncounterClose simulates, estimates fees and then sends a EncounterClose transaction to the blockchain.
      	/// </summary>
      	/// <param name="msg">The MsgEncounterClose message that should be send.</param>
		[global::System.CodeDom.Compiler.GeneratedCode("protoc-gen-cosmos-csharp", null)]
		public Task<Cosmcs.Client.ClientResponse<MsgEncounterCloseResponse>> SimulateAndSendMsgEncounterClose(MsgEncounterClose msg) {
			return SimulateMsgEncounterClose(msg).ContinueWith(r => {
				return SendMsgEncounterClose(msg, new Cosmcs.Tx.Fee((ulong) Math.Ceiling(r.Result.GasInfo.GasUsed * 1.5))).Result;
			});
		}
        
        /// <summary>
      	/// SendMsgEarlyAccessDisinvite sends a MsgEarlyAccessDisinvite transaction to the blockchain and waits
      	/// for a response.
      	/// </summary>
      	/// <param name="msg">The MsgEarlyAccessDisinvite message that should be send.</param>
      	/// <param name="fee">The fees that will be paid.</param>
        [global::System.CodeDom.Compiler.GeneratedCode("protoc-gen-cosmos-csharp", null)]
        public Task<Cosmcs.Client.ClientResponse<MsgEarlyAccessDisinviteResponse>> SendMsgEarlyAccessDisinvite(MsgEarlyAccessDisinvite msg, Cosmcs.Tx.Fee? fee = null) {
			return Client.BuildAndBroadcast(new Any[] {
				new Any
				{
					Value = msg.ToByteString(),
					TypeUrl = "/cardchain.cardchain.MsgEarlyAccessDisinvite"
				}},
				fee
			).ContinueWith(r =>
			{
				var res = r.Result;
				if (res.TxResponse.Code != 0)
				{
					return res.TxResponse;
				}
				System.Threading.Thread.Sleep(13000);
				return Client.QueryTx(res.TxResponse.Txhash).Result.TxResponse;
			})
			.ContinueWith(r => new Cosmcs.Client.ClientResponse<MsgEarlyAccessDisinviteResponse>(
				r.Result,
				MsgEarlyAccessDisinviteResponse.Parser
			));
		}

		/// <summary>
      	/// SimulateMsgEarlyAccessDisinvite simulates a MsgEarlyAccessDisinvite transaction on the blockchain.
      	/// </summary>
      	/// <param name="msg">The MsgEarlyAccessDisinvite message that should be simulated.</param>
		[global::System.CodeDom.Compiler.GeneratedCode("protoc-gen-cosmos-csharp", null)]
		public Task<Cosmos.Tx.V1beta1.SimulateResponse> SimulateMsgEarlyAccessDisinvite(MsgEarlyAccessDisinvite msg) {
			return Client.BuildAndSimulate(new Any[] {
				new Any
				{
					Value = msg.ToByteString(),
					TypeUrl = "/cardchain.cardchain.MsgEarlyAccessDisinvite"
				}}
			);
		}

		/// <summary>
      	/// SimulateAndSendMsgEarlyAccessDisinvite simulates, estimates fees and then sends a EarlyAccessDisinvite transaction to the blockchain.
      	/// </summary>
      	/// <param name="msg">The MsgEarlyAccessDisinvite message that should be send.</param>
		[global::System.CodeDom.Compiler.GeneratedCode("protoc-gen-cosmos-csharp", null)]
		public Task<Cosmcs.Client.ClientResponse<MsgEarlyAccessDisinviteResponse>> SimulateAndSendMsgEarlyAccessDisinvite(MsgEarlyAccessDisinvite msg) {
			return SimulateMsgEarlyAccessDisinvite(msg).ContinueWith(r => {
				return SendMsgEarlyAccessDisinvite(msg, new Cosmcs.Tx.Fee((ulong) Math.Ceiling(r.Result.GasInfo.GasUsed * 1.5))).Result;
			});
		}
        
        /// <summary>
      	/// SendMsgCardBan sends a MsgCardBan transaction to the blockchain and waits
      	/// for a response.
      	/// </summary>
      	/// <param name="msg">The MsgCardBan message that should be send.</param>
      	/// <param name="fee">The fees that will be paid.</param>
        [global::System.CodeDom.Compiler.GeneratedCode("protoc-gen-cosmos-csharp", null)]
        public Task<Cosmcs.Client.ClientResponse<MsgCardBanResponse>> SendMsgCardBan(MsgCardBan msg, Cosmcs.Tx.Fee? fee = null) {
			return Client.BuildAndBroadcast(new Any[] {
				new Any
				{
					Value = msg.ToByteString(),
					TypeUrl = "/cardchain.cardchain.MsgCardBan"
				}},
				fee
			).ContinueWith(r =>
			{
				var res = r.Result;
				if (res.TxResponse.Code != 0)
				{
					return res.TxResponse;
				}
				System.Threading.Thread.Sleep(13000);
				return Client.QueryTx(res.TxResponse.Txhash).Result.TxResponse;
			})
			.ContinueWith(r => new Cosmcs.Client.ClientResponse<MsgCardBanResponse>(
				r.Result,
				MsgCardBanResponse.Parser
			));
		}

		/// <summary>
      	/// SimulateMsgCardBan simulates a MsgCardBan transaction on the blockchain.
      	/// </summary>
      	/// <param name="msg">The MsgCardBan message that should be simulated.</param>
		[global::System.CodeDom.Compiler.GeneratedCode("protoc-gen-cosmos-csharp", null)]
		public Task<Cosmos.Tx.V1beta1.SimulateResponse> SimulateMsgCardBan(MsgCardBan msg) {
			return Client.BuildAndSimulate(new Any[] {
				new Any
				{
					Value = msg.ToByteString(),
					TypeUrl = "/cardchain.cardchain.MsgCardBan"
				}}
			);
		}

		/// <summary>
      	/// SimulateAndSendMsgCardBan simulates, estimates fees and then sends a CardBan transaction to the blockchain.
      	/// </summary>
      	/// <param name="msg">The MsgCardBan message that should be send.</param>
		[global::System.CodeDom.Compiler.GeneratedCode("protoc-gen-cosmos-csharp", null)]
		public Task<Cosmcs.Client.ClientResponse<MsgCardBanResponse>> SimulateAndSendMsgCardBan(MsgCardBan msg) {
			return SimulateMsgCardBan(msg).ContinueWith(r => {
				return SendMsgCardBan(msg, new Cosmcs.Tx.Fee((ulong) Math.Ceiling(r.Result.GasInfo.GasUsed * 1.5))).Result;
			});
		}
        
        /// <summary>
      	/// SendMsgEarlyAccessGrant sends a MsgEarlyAccessGrant transaction to the blockchain and waits
      	/// for a response.
      	/// </summary>
      	/// <param name="msg">The MsgEarlyAccessGrant message that should be send.</param>
      	/// <param name="fee">The fees that will be paid.</param>
        [global::System.CodeDom.Compiler.GeneratedCode("protoc-gen-cosmos-csharp", null)]
        public Task<Cosmcs.Client.ClientResponse<MsgEarlyAccessGrantResponse>> SendMsgEarlyAccessGrant(MsgEarlyAccessGrant msg, Cosmcs.Tx.Fee? fee = null) {
			return Client.BuildAndBroadcast(new Any[] {
				new Any
				{
					Value = msg.ToByteString(),
					TypeUrl = "/cardchain.cardchain.MsgEarlyAccessGrant"
				}},
				fee
			).ContinueWith(r =>
			{
				var res = r.Result;
				if (res.TxResponse.Code != 0)
				{
					return res.TxResponse;
				}
				System.Threading.Thread.Sleep(13000);
				return Client.QueryTx(res.TxResponse.Txhash).Result.TxResponse;
			})
			.ContinueWith(r => new Cosmcs.Client.ClientResponse<MsgEarlyAccessGrantResponse>(
				r.Result,
				MsgEarlyAccessGrantResponse.Parser
			));
		}

		/// <summary>
      	/// SimulateMsgEarlyAccessGrant simulates a MsgEarlyAccessGrant transaction on the blockchain.
      	/// </summary>
      	/// <param name="msg">The MsgEarlyAccessGrant message that should be simulated.</param>
		[global::System.CodeDom.Compiler.GeneratedCode("protoc-gen-cosmos-csharp", null)]
		public Task<Cosmos.Tx.V1beta1.SimulateResponse> SimulateMsgEarlyAccessGrant(MsgEarlyAccessGrant msg) {
			return Client.BuildAndSimulate(new Any[] {
				new Any
				{
					Value = msg.ToByteString(),
					TypeUrl = "/cardchain.cardchain.MsgEarlyAccessGrant"
				}}
			);
		}

		/// <summary>
      	/// SimulateAndSendMsgEarlyAccessGrant simulates, estimates fees and then sends a EarlyAccessGrant transaction to the blockchain.
      	/// </summary>
      	/// <param name="msg">The MsgEarlyAccessGrant message that should be send.</param>
		[global::System.CodeDom.Compiler.GeneratedCode("protoc-gen-cosmos-csharp", null)]
		public Task<Cosmcs.Client.ClientResponse<MsgEarlyAccessGrantResponse>> SimulateAndSendMsgEarlyAccessGrant(MsgEarlyAccessGrant msg) {
			return SimulateMsgEarlyAccessGrant(msg).ContinueWith(r => {
				return SendMsgEarlyAccessGrant(msg, new Cosmcs.Tx.Fee((ulong) Math.Ceiling(r.Result.GasInfo.GasUsed * 1.5))).Result;
			});
		}
        
        /// <summary>
      	/// SendMsgSetActivate sends a MsgSetActivate transaction to the blockchain and waits
      	/// for a response.
      	/// </summary>
      	/// <param name="msg">The MsgSetActivate message that should be send.</param>
      	/// <param name="fee">The fees that will be paid.</param>
        [global::System.CodeDom.Compiler.GeneratedCode("protoc-gen-cosmos-csharp", null)]
        public Task<Cosmcs.Client.ClientResponse<MsgSetActivateResponse>> SendMsgSetActivate(MsgSetActivate msg, Cosmcs.Tx.Fee? fee = null) {
			return Client.BuildAndBroadcast(new Any[] {
				new Any
				{
					Value = msg.ToByteString(),
					TypeUrl = "/cardchain.cardchain.MsgSetActivate"
				}},
				fee
			).ContinueWith(r =>
			{
				var res = r.Result;
				if (res.TxResponse.Code != 0)
				{
					return res.TxResponse;
				}
				System.Threading.Thread.Sleep(13000);
				return Client.QueryTx(res.TxResponse.Txhash).Result.TxResponse;
			})
			.ContinueWith(r => new Cosmcs.Client.ClientResponse<MsgSetActivateResponse>(
				r.Result,
				MsgSetActivateResponse.Parser
			));
		}

		/// <summary>
      	/// SimulateMsgSetActivate simulates a MsgSetActivate transaction on the blockchain.
      	/// </summary>
      	/// <param name="msg">The MsgSetActivate message that should be simulated.</param>
		[global::System.CodeDom.Compiler.GeneratedCode("protoc-gen-cosmos-csharp", null)]
		public Task<Cosmos.Tx.V1beta1.SimulateResponse> SimulateMsgSetActivate(MsgSetActivate msg) {
			return Client.BuildAndSimulate(new Any[] {
				new Any
				{
					Value = msg.ToByteString(),
					TypeUrl = "/cardchain.cardchain.MsgSetActivate"
				}}
			);
		}

		/// <summary>
      	/// SimulateAndSendMsgSetActivate simulates, estimates fees and then sends a SetActivate transaction to the blockchain.
      	/// </summary>
      	/// <param name="msg">The MsgSetActivate message that should be send.</param>
		[global::System.CodeDom.Compiler.GeneratedCode("protoc-gen-cosmos-csharp", null)]
		public Task<Cosmcs.Client.ClientResponse<MsgSetActivateResponse>> SimulateAndSendMsgSetActivate(MsgSetActivate msg) {
			return SimulateMsgSetActivate(msg).ContinueWith(r => {
				return SendMsgSetActivate(msg, new Cosmcs.Tx.Fee((ulong) Math.Ceiling(r.Result.GasInfo.GasUsed * 1.5))).Result;
			});
		}
        
        /// <summary>
      	/// SendMsgCardCopyrightClaim sends a MsgCardCopyrightClaim transaction to the blockchain and waits
      	/// for a response.
      	/// </summary>
      	/// <param name="msg">The MsgCardCopyrightClaim message that should be send.</param>
      	/// <param name="fee">The fees that will be paid.</param>
        [global::System.CodeDom.Compiler.GeneratedCode("protoc-gen-cosmos-csharp", null)]
        public Task<Cosmcs.Client.ClientResponse<MsgCardCopyrightClaimResponse>> SendMsgCardCopyrightClaim(MsgCardCopyrightClaim msg, Cosmcs.Tx.Fee? fee = null) {
			return Client.BuildAndBroadcast(new Any[] {
				new Any
				{
					Value = msg.ToByteString(),
					TypeUrl = "/cardchain.cardchain.MsgCardCopyrightClaim"
				}},
				fee
			).ContinueWith(r =>
			{
				var res = r.Result;
				if (res.TxResponse.Code != 0)
				{
					return res.TxResponse;
				}
				System.Threading.Thread.Sleep(13000);
				return Client.QueryTx(res.TxResponse.Txhash).Result.TxResponse;
			})
			.ContinueWith(r => new Cosmcs.Client.ClientResponse<MsgCardCopyrightClaimResponse>(
				r.Result,
				MsgCardCopyrightClaimResponse.Parser
			));
		}

		/// <summary>
      	/// SimulateMsgCardCopyrightClaim simulates a MsgCardCopyrightClaim transaction on the blockchain.
      	/// </summary>
      	/// <param name="msg">The MsgCardCopyrightClaim message that should be simulated.</param>
		[global::System.CodeDom.Compiler.GeneratedCode("protoc-gen-cosmos-csharp", null)]
		public Task<Cosmos.Tx.V1beta1.SimulateResponse> SimulateMsgCardCopyrightClaim(MsgCardCopyrightClaim msg) {
			return Client.BuildAndSimulate(new Any[] {
				new Any
				{
					Value = msg.ToByteString(),
					TypeUrl = "/cardchain.cardchain.MsgCardCopyrightClaim"
				}}
			);
		}

		/// <summary>
      	/// SimulateAndSendMsgCardCopyrightClaim simulates, estimates fees and then sends a CardCopyrightClaim transaction to the blockchain.
      	/// </summary>
      	/// <param name="msg">The MsgCardCopyrightClaim message that should be send.</param>
		[global::System.CodeDom.Compiler.GeneratedCode("protoc-gen-cosmos-csharp", null)]
		public Task<Cosmcs.Client.ClientResponse<MsgCardCopyrightClaimResponse>> SimulateAndSendMsgCardCopyrightClaim(MsgCardCopyrightClaim msg) {
			return SimulateMsgCardCopyrightClaim(msg).ContinueWith(r => {
				return SendMsgCardCopyrightClaim(msg, new Cosmcs.Tx.Fee((ulong) Math.Ceiling(r.Result.GasInfo.GasUsed * 1.5))).Result;
			});
		}
        
	}
	
}
